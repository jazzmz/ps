/*
                 Банковская интегрированная система БИСквит
      Copyright: (C) 1992-2004 ТОО "Банковские информационные системы"
       Filename: PP-I254.P
        Comment: Библиотека функций для вычисления показателей, связанных
                 с расчетом резерва по ссудам (Инструкция 254-П)
     Parameters:
           Uses:
        Used by:
        Created: 12.07.2004 AMAM
         Modify: 21.01.2008 jadv (0085692) Добавлены функции LnFormRsrvDiskBad(),
                                  LnFormRsrvVProcGood(), LnFormRsrvVDiskGood()
                                  и процедура LnFormRsrvVek.
         Modify: 20.02.2008 jadv (0086632) Доработка LnFormRsrvProc и LnCalcRsrvProc
         Modify: 18.09.2008 jadv (0098607) При вызове LnCollateralValueEx из ClcAcctDeriv передаем валюту "", т.е. рубли

   F/P  Name                   Comment
   ───  ───────────────────  ────────────────────────────────────────────────────
   F    LnRsrvRate           Возвращает значение ставки резервирования по договору
                             за указанную дату
   F    LnPrincipal          Возвращает общую величину основного долга по договору
                             за указанную дату. Для договоров с течениями будет
                             возвращена общая сумма основного долга по всем траншам.
   F    LnGoodDebt           Возвращает величину срочной задолженности по договору
                             за указанную дату. Для договоров с течениями будет
                             возвращена общая сумма срочной задолженности по всем
                             траншам.
   F    LnBadDebt            Возвращает величину просроченной задолженности по
                             договору за указанную дату. Для договоров с течениями
                             будет возвращена общая сумма просроченной задолженности
                             по всем траншам.
   F    LnSyndLoan           Возвращает признак договора - является ли он синдицированной
                             ссудой.
   F    LnOptionClause       Возвращает признак опционной оговорки по депозитному
                             договору.
   F    LnPartAmt            Возвращает для кредитного договора общую сумму средств,
                             привлеченных по этому договору от участников синдицированного
                             кредита.
   F    LnPersRisk           Возвращает признак наличия индивидуальных коэффициентов
                             резервирования по траншам кредитного договора с течениями.
   F    LnRsrvCheck          Возвращает логическое значение ИСТИНА, если резерв должен
                             учитываться в параметрах договора, иначе - значение ЛОЖЬ.
   F    LnCalcRsrv           Возвращает величину расчетного резерва по договору. Если
                             на договоре не ведется учет резерва, то функция возвращает
                             ноль. По договорам с течениями расчетный резерв будет
                             определен для всех траншей договора.
   F   LnPledge              Возвращает оценочную стоимость объекта обеспечения без
                             учета значений коэффициента снижения стоимости и индекса
                             качества обеспечения.
   F   LnCollateralValue     Вычисляет часть суммы обеспечения по основному долгу по указанному
                             договору с учетом индекса качества обеспечения и коэффициента снижения
                             стоимости обеспечения.
   F   LnCollateralValueAll  Вычисляет общую сумму обеспечения по указанному договору с
                             учетом индекса качества обеспечения и коэффициента снижения
                             стоимости обеспечения.
 F   LnCollateralValueAllEx  Вычисляет общую сумму обеспечения по указанному договору (с
                             учетом/без учета) индекса качества обеспечения и коэффициента
                             снижения стоимости обеспечения.
   F   LnUncoveredLoan       Вычисляет необеспеченную часть ссуды,относящуюся к
                             отдельному договору. Не работает с договорами типа "Течение".
   F   LnCollateralValueAgr  Вычисляет часть суммы обеспечения, зарегистрированного по
                             соглашению о траншевой кредитной линии, относящуюся к
                             данному траншу.
   F   LnFormRsrv            Возвращает величину формируемого резерва по договору.
                             Если в договоре не ведется учет резерва, то функция
                             возвратит ноль. По договорам с течениями формируемый
                             резерв будет определен для всех траншей договора.
   F   LnFormRsrvGoodDebt    Возвращает часть суммы формируемого резерва, относящуюся
                             к срочной задолженности по договору.
   F   LnFormRsrvBadDebt     Возвращает часть суммы формируемого резерва, относящуюся
                             к просроченной задолженности по договору.
 F LnFormRsrvGoodDebtTransh  Возвращает часть суммы формируемого резерва, относящуюся
                             к срочной задолженности по договору.
                             Предназначена для расчета резерва, относящегося к траншу.
                             Возвращает 0 по договорам типа "Течение".
 F LnFormRsrvBadDebtTransh   Возвращает часть суммы формируемого резерва, относящуюся
                             к просроченной задолженности по договору.
                             Предназначена для расчета резерва, относящегося к траншу.
                             Возвращает 0 по договорам типа "Течение".
   F   LnGetGrRiska          Определение группы риска по значению коэффициента
                             резервирования.
   F   LnRsrvDate            возвращает значение ставки резервирования по договору
                             за указанную дату.
   P   LnGetRiskGrOnDate     Определение группы риска по значению коэффициента
                             резервирования.
   P   LnPersRsrvOnDate
   F   re_history_risk       Определение группы риска договора на дату по истории.
   F   LnPledgeQuality       возвращает стоимость объекта обеспечения с учетом
                             значений коэффициента снижения стоимости и индекса
                             качества обеспечения.
   F   RegulationNeed        Функция фиксирующая изменение факторов, влияющих на
                             размер резерва.
   F   LnCalcRsrvTransh      Возвращает величину расчетного резерва по договору. Если
                             на договоре не ведется учет резерва, то функция возвращает
                             ноль. Для договоров, имеющих тип "Течение" возвращает ноль.
   F   LnFormRsrvTransh      Возвращает величину формируемого резерва по договору.
                             Если в договоре не ведется учет резерва, то функция
                             возвратит ноль. Для договоров, имеющих тип "Течение"
                             возвращает ноль.
   F   LnRsrvBal             Возвращает остаток резерва по срочной и просроченной
                             задолженности, фактически созданного по договору, на указанную
                             дату.
   F   LnRsrvBalGoodDebt     Возвращает остаток резерва по срочной задолженности, фактически
                             созданного по договору на указанную дату.
   F   LnRsrvBalBadDebt      Возвращает остаток резерва по просроченной задолженности,
                             фактически созданного по договору на указанную дату.
   F   LnRsrvBalTransh       Возвращает остаток резерва по срочной и просроченной
                             задолженности, фактически созданного по договору, на указанную
                             дату. Если договор имеет тип "Течение" возвращает ноль.
 F LnRsrvBalGoodDebtTransh   Возвращает остаток резерва по срочной задолженности, фактически
                             созданного по договору, на указанную дату. Если договор имеет
                             тип "Течение" возвращает ноль.
 F LnRsrvBalBadDebtTransh    Возвращает остаток резерва по просроченной задолженности,
                             фактически созданного по договору, на указанную дату.
                             Если договор имеет тип "Течение" возвращает ноль.
 P LnTurnoverDb              Расчет величины суммарного оборота по предоставлению ссуды и
                             положительной переоценке с начала отчетного месяца.
 F LnAvgTurnoverDb           Расчет величины среднего оборота по предоставлению ссуды и
                             переоценке с начала отчетного месяца в валюте результата
                             iCurrency.
 F LnIsOffShoreOperation     Определяет является ли ссуда операцией с резидентом офшора.
 F LnOffShoreCode            Определяет код офшорной зоны, к которой относится договор.
 P LnORsrvCalcBase           Расчет базы для определения минимальной величины формируемого
                             резерва.
 F LnORsrvRate               Возвращает размер доли отчислений в резерв под ссуду,
                             предоставленную резиденту офшорной зоны.
 F Get_QualityGar            Возвращает значение категории качества обеспечения на дату.
 F Get_VidObespech           Возвращает значение вида обеспечения на дату.
 F GetLast_QualityGar        Возвращает последнее, указанное значение категории качества
                             обеспечения.
 F Set_QualityGar            Создает запись категории качества на обеспечении.

 F Get_NachBal               Определяет, где начислять проценты - на балансе или внебалансе (0083188)
 F GetChanges_GrRiska        Определяет факт изменения в текущем дне группы риска (0083188)
 F LnFormRsrvDiskBad         Расчет резерва для просроченного дисконта.
 F LnFormRsrvVProcGood       Расчет резерва для УВ по процентам.
 F LnFormRsrvVDiskGood       Расчет резерва для УВ по дисконту.
 F LnFormRsrvVek             Расчет резерва учтенных векселей по начисленным процентам/дисконту.
 F LnFormRsrvVb              Расчет резерва по условным обязательствам 
 F LnGetExtraditionSum       Возвращает сумму выданного кредита.                             
 
*/

{globals.i}             /* Глобальные константы */
{intrface.get instrum}  /* функции работы с финансовыми инструментами */
{intrface.get xclass}   /* Функции работы с метасхемой */
{intrface.get comm}     /* Инструменты для работы с комиссиями */
{intrface.get loan}     /* Инструменты для работы с табличкой loan. */
{intrface.get date}     /* Инструменты для работы с датами. */
{intrface.get refer}    /* Библиотека для работы со службой "Справочники". */
{intrface.get db2l}
{intrface.get tmess}
{gr-rsrv.pro}
{sh-defs.i}
{tt-cr.def}
{ppi254.api}
DEF STREAM out_s.

DEFINE TEMP-TABLE tt-Loan NO-UNDO
   FIELD ContCode AS CHARACTER
   FIELD DocRef   LIKE loan.doc-ref
INDEX pi IS UNIQUE ContCode.

/* таблица для вычисления LnGetProvAcct */
DEFINE TEMP-TABLE tt-Loan-ob NO-UNDO
   FIELD ContCode       AS CHARACTER
   FIELD Acct           AS CHARACTER
   FIELD ObSum          AS DECIMAL   /* общая сумма обеспечения */
   FIELD TranshSum      AS DECIMAL   /* общая сумма всех траншей */
   FIELD AcctSum        AS DECIMAL   /* общая сумма в рамках конкретного счета */
   FIELD IfLast         AS LOGICAL   /* признак последний/не последний счет */
   FIELD IfTransh       AS LOGICAL   /* признак транш / не транш */
INDEX pu IS UNIQUE ContCode Acct.

/* Для оптимизации вынос чтения значений НП в начало библиотеки (0095860) ????  */
DEF VAR mIfPutPtot    AS LOG  NO-UNDO.
DEF VAR mIfPutNotNull AS LOG  NO-UNDO.
DEF VAR mVerRel_Type  AS LOGICAL NO-UNDO .
DEF VAR mSpisBaseParam  AS CHARACTER NO-UNDO . /*Список параметров срочной задолженности*/
DEF VAR mSpisBaseParamP AS CHARACTER NO-UNDO . /*Список параметров просрочной задолженности*/

ASSIGN
   mIfPutPtot    = FGetSetting("i254Stream", "", "") = "Да"         /* Определяет выводить ли в OUTPUT STREAM out_s TO "loanrsrv.log"  */
   mIfPutNotNull = FGetSetting("i254StrTNull", "", "") = "Нет"      /* Определяет, нужно ли выводить нулевые транши в "loanrsrv.log" */
.

FUNCTION LnRsrvOffShore RETURNS DECIMAL (INPUT iContract AS CHAR,
                                         INPUT iContCode AS CHAR,
                                         INPUT iDate     AS DATE,
                                         INPUT iCurrency AS CHAR,
                                         INPUT iResult   AS DEC) FORWARD.

/*
  возвращает код портфеля которому принадлежит договор
 */
FUNCTION IsPortfolioLoan RETURNS CHAR
   (iContract AS CHAR,
    iContCode AS CHAR):

   DEF VAR vBag AS CHAR NO-UNDO.

   vBag = GetXAttrValueEx("loan",
                          iContract + "," + iContCode,
                          "UniformBag",
                          "").

   RETURN (IF NUM-ENTRIES(iContCode," ") = 2 THEN
              (IF NOT {assignex vBag}
               THEN IsPortfolioLoan(iContract,ENTRY(1,iContCode," "))
               ELSE vBag)
           ELSE vBag).

END FUNCTION.

FUNCTION loanNotFound RETURN LOGICAL (iContCode AS CHAR) :
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Ошибка    Код договора : " iContCode FORMAT "X(22)"
         ".  Договор не найден."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
END FUNCTION.

/*----------------------------------------------------------------------------
  Function   : LnFInside
  Name       :
  Purpose    : Определение, входит - ли величина в диапазон
  Parameters :
  Notes      :
  ----------------------------------------------------------------------------*/
FUNCTION LnFInside RETURNS LOGICAL
   (INPUT  iFormula AS CHAR,
    INPUT  iKfc     AS DECIMAL,
    OUTPUT vMin     AS DECIMAL):

   DEFINE VARIABLE vMax AS DECIMAL    NO-UNDO INIT ?.
   DEFINE VARIABLE vVal AS CHARACTER  NO-UNDO.
   /* Разбор переданой формулы */
   ASSIGN
      vVal = TRIM (iFormula, CHR (126))  /* Отсекаем тильду */
      vMin = DEC (ENTRY (1,vVal))
      vMax = DEC (ENTRY (NUM-ENTRIES (vVal),vVal))
   NO-ERROR.
   /* Ошибка - не учитываем */
   IF ERROR-STATUS:ERROR THEN RETURN NO.

   IF (vMax EQ ?) OR (vMax EQ vMin)
      THEN RETURN (iKfc LE vMin).
      ELSE RETURN (iKfc GE vMin AND iKfc LT vMax).

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnIsOffShoreOperation
  Name       : Является ли ссуда операцией с резидентом офшора
  Purpose    : Определяет является ли ссуда операцией с резидентом офшора.
               Возвращает логическое значение.
  Parameters : iContract - назначение договора
               iContCode - номер договора
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnIsOffShoreOperation RETURNS LOGICAL (INPUT iContract AS CHAR,
                                                INPUT iContCode AS CHAR).

   DEFINE VARIABLE vCustCat AS CHARACTER        NO-UNDO.
   DEFINE VARIABLE vCustId  AS INT64          NO-UNDO.
   DEFINE VARIABLE vOfShore AS CHARACTER INIT ? NO-UNDO.

   DEFINE BUFFER b-loan FOR loan.

   RUN RE_B_LOAN IN h_Loan (iContract, iContCode, BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   FIND FIRST cust-role WHERE
              cust-role.file-name  = "loan"
          AND cust-role.surrogate  = iContract + "," + iContCode
          AND cust-role.Class-Code = "loan-cust-off-shore"
   NO-LOCK NO-ERROR.

   IF AVAIL cust-role THEN
      ASSIGN
         vCustCat = cust-role.cust-cat
         vCustId  = INT64(cust-role.cust-id)
         .
   ELSE
      ASSIGN
         vCustCat = b-loan.cust-cat
         vCustId  = b-loan.cust-id
         .

   CASE vCustCat:
      WHEN 'Ю' THEN DO:
         FIND FIRST cust-corp WHERE cust-corp.cust-id = vCustId NO-LOCK NO-ERROR.
         IF AVAIL cust-corp THEN
            vOfShore = GetXAttrValueEx("cust-corp", STRING(vCustId), "Офшор", ?).
      END.
      WHEN 'Ч' THEN DO:
         FIND FIRST person WHERE person.person-id = vCustId NO-LOCK NO-ERROR.
         IF AVAIL person THEN
            vOfShore = GetXAttrValueEx("person", STRING(vCustId), "Офшор", ?).
      END.
      WHEN 'Б' THEN DO:
         FIND FIRST banks WHERE banks.bank-id = vCustId NO-LOCK NO-ERROR.
         IF AVAIL banks THEN
            vOfShore = GetXAttrValueEx("banks", STRING(vCustId), "Офшор", ?).
      END.
   END CASE.

   IF vOfShore <> ? AND vOfShore <> "" THEN RETURN TRUE.

   RETURN FALSE.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnOffShoreCode
  Name       : Код офшора, к которому относится договор
  Purpose    : Определяет код офшорной зоны, к которой относится договор.
               Возвращает символьное значение.
  Parameters : iContract - назначение договора
               iContCode - номер договора
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnOffShoreCode RETURNS CHARACTER (INPUT iContract AS CHAR,
                                           INPUT iContCode AS CHAR).

   DEFINE VARIABLE vCustCat AS CHARACTER        NO-UNDO.
   DEFINE VARIABLE vCustId  AS INT64          NO-UNDO.
   DEFINE VARIABLE vOfShore AS CHARACTER INIT ? NO-UNDO.

   DEFINE BUFFER b-loan FOR loan.

   RUN RE_B_LOAN IN h_Loan (iContract, iContCode, BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   FIND FIRST cust-role WHERE
              cust-role.file-name  = "loan"
          AND cust-role.surrogate  BEGINS ENTRY(1, iContract + "," + iContCode, " ")
          AND cust-role.Class-Code = "loan-cust-off-shore"
   NO-LOCK NO-ERROR.

   IF AVAIL cust-role THEN
      ASSIGN
         vCustCat = cust-role.cust-cat
         vCustId  = INT64(cust-role.cust-id)
         .
   ELSE
      ASSIGN
         vCustCat = b-loan.cust-cat
         vCustId  = b-loan.cust-id
         .

   CASE vCustCat:
      WHEN 'Ю' THEN DO:
         FIND FIRST cust-corp WHERE cust-corp.cust-id = vCustId NO-LOCK NO-ERROR.
         IF AVAIL cust-corp THEN
            vOfShore = GetXAttrValueEx("cust-corp", STRING(vCustId), "Офшор", ?).
      END.
      WHEN 'Ч' THEN DO:
         FIND FIRST person WHERE person.person-id = vCustId NO-LOCK NO-ERROR.
         IF AVAIL person THEN
            vOfShore = GetXAttrValueEx("person", STRING(vCustId), "Офшор", ?).
      END.
      WHEN 'Б' THEN DO:
         FIND FIRST banks WHERE banks.bank-id = vCustId NO-LOCK NO-ERROR.
         IF AVAIL banks THEN
            vOfShore = GetXAttrValueEx("banks", STRING(vCustId), "Офшор", ?).
      END.
   END CASE.

   IF vOfShore <> ? AND vOfShore <> "" THEN RETURN vOfShore.

   RETURN ?.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnRsrvRate
  Name       : Коэффициент резервирования
  Purpose    : возвращает значение ставки резервирования по договору за
               указанную дату

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvRate RETURNS DECIMAL (
   INPUT iContract AS CHAR,
   INPUT iContCode AS CHAR,
   INPUT iDate     AS DATE
):
   DEF VAR vRate AS DEC    NO-UNDO.
   DEF VAR vPos  AS CHAR   NO-UNDO. /* Код ПОСа. */

   DEF BUFFER loan FOR loan. /* Локализация буфера. */

                        /* Если ссуда входит в ПОС, то определяем ставку по ПОСу. */
   vPos = LnInBagOnDate (iContract, iContCode, iDate).

   IF     vPos NE ?
   THEN DO:
      FIND FIRST loan WHERE
               loan.contract  EQ "ПОС"
         AND   loan.cont-code EQ vPos
      NO-LOCK NO-ERROR.
      IF AVAIL loan THEN
      DO:
         vRate = DEC (fGetBagRate ((BUFFER loan:handle), "%Рез", iDate, "rate-comm")).
         IF vRate EQ ? THEN
            vRate = 0.
      END.
   END.
   ELSE DO:
      /* поиск хронологически последнего коэффициента резервирования по договору */
      RUN GET_COMM_LOAN_BUF IN h_Loan (iContract,
                                       iContCode,
                                       "%Рез",
                                       iDate,
                                       BUFFER comm-rate).

      IF AVAIL comm-rate THEN vRate = comm-rate.rate-comm.
      /* договор не типа "течение" -> смотрим вышестоящий договор */
      ELSE IF     NOT CAN-FIND(loan WHERE loan.contract  EQ iContract
                                      AND loan.cont-code EQ iContCode
                                      AND loan.cont-type = "Течение" )
              AND NUM-ENTRIES(iContCode, " ") = 2
           THEN
              vRate = (LnRsrvRate (iContract,
                                   ENTRY(1,iContCode, " "),
                                   iDate)).
   END.
   RETURN vRate.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnRsrvRateVb
  Name       : Коэффициент резервирования
  Purpose    : возвращает значение ставки резервирования по счету привязанному
               к договору за указанную дату
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iRole       - роль счета
               iDate       - дата операции
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvRateVb RETURNS DECIMAL (
   INPUT iContract AS CHAR,
   INPUT iContCode AS CHAR,
   INPUT iRole     AS CHAR,
   INPUT iDate     AS DATE
):
   DEF VAR vRate     AS DEC   NO-UNDO.
   DEF VAR vFindAcct AS LOG  NO-UNDO. /* искать счета. */
   DEF VAR vChkDP    AS LOG  NO-UNDO. /* проверять значение ДР на счете. */

   DEF BUFFER loan      FOR loan.      /* Локализация буфера. */
   DEF BUFFER loan-acct FOR loan-acct. /* Локализация буфера. */
   DEF BUFFER comm-rate FOR comm-rate. /* Локализация буфера. */

   MAIN:
   DO:
      FIND FIRST loan WHERE
                 loan.contract  EQ iContract
             AND loan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN
         LEAVE MAIN.
      CASE FGetSetting("ИндПрРезВн", "", ""):
         WHEN "ДА" THEN
            vFindAcct = TRUE.
         WHEN "НЕТ" THEN
            vFindAcct = FALSE.
         WHEN "" THEN
            ASSIGN
               vFindAcct = TRUE
               vChkDP = TRUE
            .
            /* Да, кроме ПОС */
         OTHERWISE
            vFindAcct = LnInBagOnDate (loan.contract,
                                       loan.cont-code,
                                       loan.since) EQ ?.
      END CASE.
      IF vFindAcct THEN
         /* получаем резерв со счета */
      DO:
         FIND LAST loan-acct WHERE
                   loan-acct.contract  EQ iContract
               AND loan-acct.cont-code EQ iContCode
               AND loan-acct.acct-type EQ iRole
               AND loan-acct.since     LE iDate
         NO-LOCK NO-ERROR.
         IF NOT AVAIL loan-acct THEN
            LEAVE MAIN.
         IF    NOT vChkDP
            OR GetXattrValueEx("acct",
                                loan-acct.acct + "," + loan-acct.currency,
                                "ИндПрРез",
                                "") EQ "ДА" THEN
         DO:
            FIND LAST comm-rate WHERE
                      comm-rate.commission EQ "%Рез"
                  AND comm-rate.filial-id = shfilial
                  AND comm-rate.branch-id = ""
                  AND comm-rate.acct       EQ loan-acct.acct
                  AND comm-rate.currency   EQ loan-acct.currency
                  AND comm-rate.kau        EQ ""
                  AND comm-rate.min-value  EQ 0.00
                  AND comm-rate.period     EQ 0
                  AND comm-rate.since      LE iDate
            NO-LOCK NO-ERROR.
            IF AVAIL comm-rate THEN
               vRate = comm-rate.rate-comm.
            LEAVE MAIN.
         END.
      END.
         /* получаем резерв с договора */
      vRate = LnRsrvRate (iContract,
                          iContCode,
                          iDate).
   END.
   RETURN vRate.
END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnPrincipal
  Name       : Основной долг
  Purpose    : возвращает общую величину основного долга по договору за
               указанную дату. Для договоров с течениями будет возвращена
               общая сумма основного долга по всем траншам.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnPrincipal RETURNS DECIMAL (INPUT iContract AS CHAR,
                                      INPUT iContCode AS CHAR,
                                      INPUT iDate     AS DATE,
                                      INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan FOR loan.

   DEF VAR mspar      AS CHAR NO-UNDO. /* список параметров */
   DEF VAR mi         AS INT64  NO-UNDO.
   DEF VAR mpar       AS INT64  NO-UNDO.
   DEF VAR mLoanCurr  AS CHAR NO-UNDO. /* валюта договора */
   DEF VAR vParamSumm AS DEC  EXTENT 10 NO-UNDO.
   DEF VAR vDb        AS DEC  NO-UNDO.
   DEF VAR vCr        AS DEC  NO-UNDO.
   DEF VAR vRes       AS DEC  NO-UNDO.
   DEF VAR mResult    AS DEC  NO-UNDO.
   DEF VAR oResVer    AS CHARACTER NO-UNDO .
   DEF VAR oResVerP   AS CHARACTER NO-UNDO .

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   DEFINE VARIABLE vDoc-ref AS CHAR NO-UNDO.
   vDoc-ref = b-loan.doc-ref .

   Run GetSpisBaseParam IN THIS-PROCEDURE  (OUTPUT oResVer, OUTPUT oResVerP).
   mspar = "0,7,13". /* параметры для расчета сумм остатков */
   IF oResVer <> "" THEN mspar = Trim(oResVer,",") + "," + Trim(oResVerP,",") .
   /* договор не имеет тип "Течение" */
   IF b-loan.cont-type <> "Течение" THEN DO:
       DO mi = 1 TO NUM-ENTRIES(mspar):

          mpar = INT64(ENTRY(mi,mspar)).

          RUN RE_PARAM_EX IN h_Loan (
               mpar,                    /* Код параметра */
               iDate,                   /* Дата расчета */
               b-loan.since,
               iContract,               /* Тип договора */
               iContCode,               /* Номер договора */
               OUTPUT vParamSumm[mi],   /* Сумма параметра */
               OUTPUT vDb,              /* Дебет обороты */
               OUTPUT vCr).             /* Кредитовые обороты */

          vRes = vRes + IF b-loan.Currency <> iCurrency
                        THEN CurToCurWork("Учетный",
                                          b-loan.currency,
                                          iCurrency,
                                          iDate,
                                          vParamSumm[mi])
                        ELSE vParamSumm[mi].

       END.

       IF mIfPutPtot
          AND NOT(mIfPutNotNull
                  AND NUM-ENTRIES(vDoc-ref, " ") = 2
                  AND vRes = 0 ) THEN
       DO:
          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
              "Информация  Договор: " vDoc-ref FORMAT "X(22)"
              ".  Вычисление Общей задолженности по договору (срочной и просроченной) за "
              STRING(iDate, "99/99/9999") + "."
              SKIP.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " vDoc-ref FORMAT "X(22)"
             ".  Список параметров договора для расчета: "
             mspar FORMAT "x(30)"
             SKIP.
          DO mi = 1 TO NUM-ENTRIES(mspar):
              PUT STREAM out_s UNFORMATTED
                 "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                 ".  Параметр "
                 INT64(ENTRY(mi,mspar)) FORMAT ">9"
                 ". Остаток в валюте "
                 b-loan.Currency FORMAT "x(3)"
                 ": "
                 vParamSumm[mi] FORMAT "->>>,>>>,>>>,>>9.99"
                 SKIP.
          END.
          OUTPUT STREAM out_s CLOSE.
       END.

   END.
   ELSE
   DO:
      /* для всех течений договора, кроме тех, которые открыты позже iDate
         или закрыты ранее iDate
      */
      IF mIfPutPtot THEN
      DO:
          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
                  "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                  ".  Вычисление Общей задолженности по договору (срочной и просроченной) за "
                  STRING(iDate, "99/99/9999") + "."
                  SKIP.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " vDoc-ref FORMAT "X(22)"
             ".  Договор имеет тип 'Течение'. Расчет величины Общей задолженности будет выполнен по подчиненным договорам."
             SKIP.
          OUTPUT STREAM out_s CLOSE.
      END.

      FOR EACH b-loan WHERE
               b-loan.contract = iContract
           AND b-loan.cont-code BEGINS iContCode
           AND NUM-ENTRIES(b-loan.cont-code, " ") = 2
           AND ENTRY(1, b-loan.cont-code, " ")    = iContCode
           AND b-loan.open-date <= iDate
      NO-LOCK:

         IF b-loan.close-date <> ? AND
            b-loan.close-date <= iDate
         THEN
            NEXT.

         vRes = vRes +  LnPrincipal(b-loan.contract,
                                    b-loan.cont-code,
                                    iDate,
                                    iCurrency).

      END. /*FOR EACH*/

   END.

   mResult = CurrRound(vRes,iCurrency).

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(vDoc-ref, " ") = 2
              AND mResult = 0) THEN
   DO:
       OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " vDoc-ref FORMAT "X(22)"
          ".  Общая задолженность по договору в валюте "
          iCurrency FORMAT "x(3)"
          ": "
          mResult FORMAT "->>>,>>>,>>>,>>9.99"
          SKIP.
       OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnGoodDebt
  Name       : Срочная задолженность
  Purpose    : возвращает величину срочной задолженности по договору за
               указанную дату. Для договоров с течениями будет возвращена
               общая сумма срочной задолженности по всем траншам.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnGoodDebt RETURNS DECIMAL (INPUT iContract AS CHAR,
                                     INPUT iContCode AS CHAR,
                                     INPUT iDate     AS DATE,
                                     INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan FOR loan.

   DEF VAR mspar      AS CHAR NO-UNDO. /* список параметров */
   DEF VAR mi         AS INT64  NO-UNDO.
   DEF VAR mpar       AS INT64  NO-UNDO.
   DEF VAR mLoanCurr  AS CHAR NO-UNDO. /* валюта договора */
   DEF VAR vParamSumm AS DEC EXTENT 10 NO-UNDO.
   DEF VAR vDb        AS DEC  NO-UNDO.
   DEF VAR vCr        AS DEC  NO-UNDO.
   DEF VAR vRes       AS DEC  NO-UNDO.
   DEF VAR mResult    AS DEC  NO-UNDO.
   DEF VAR oResVer AS CHARACTER NO-UNDO .
   DEF VAR oResVerP AS CHARACTER NO-UNDO .

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   DEFINE VARIABLE vDoc-ref AS CHAR NO-UNDO.
   vDoc-ref = b-loan.doc-ref .

   ASSIGN
      mspar = "0,13"              /* параметры для расчета сумм остатков */
      mLoanCurr = b-loan.Currency.

   Run GetSpisBaseParam IN THIS-PROCEDURE  (OUTPUT oResVer, OUTPUT oResVerP).
   IF oResVer <> "" THEN mspar = Trim(oResVer,",") .



   /* договор не имеет тип "Течение" */
   IF b-loan.cont-type <> "Течение" THEN DO:
       DO mi = 1 TO NUM-ENTRIES(mspar):

          mpar = INT64(ENTRY(mi,mspar)).

          RUN RE_PARAM_EX IN h_Loan (
               mpar,                    /* Код параметра */
               iDate,                   /* Дата расчета */
               b-loan.since,
               iContract,               /* Тип договора */
               iContCode,               /* Номер договора */
               OUTPUT vParamSumm[mi],       /* Сумма параметра */
               OUTPUT vDb,              /* Дебет обороты */
               OUTPUT vCr).             /* Кредитовые обороты */

          vRes = vRes + IF b-loan.Currency <> iCurrency
                        THEN CurToCurWork("Учетный",
                                          b-loan.currency,
                                          iCurrency,
                                          iDate,
                                          vParamSumm[mi])
                        ELSE vParamSumm[mi].
       END.
       IF mIfPutPtot
           AND NOT(mIfPutNotNull
                   AND NUM-ENTRIES(vDoc-ref, " ") = 2
                   AND vRes = 0) THEN
       DO:
          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
              "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
              ".  Вычисление Срочной задолженности по договору за "
              STRING(iDate, "99/99/9999") + "."
              SKIP.

          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
             ".  Список параметров договора для расчета: "
             mspar FORMAT "x(30)"
             SKIP.

          DO mi = 1 TO NUM-ENTRIES(mspar):
              PUT STREAM out_s UNFORMATTED
                 "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
                 ".  Параметр "
                 INT64(ENTRY(mi,mspar)) FORMAT ">>>9"
                 ". Остаток в валюте "
                 b-loan.Currency FORMAT "x(3)"
                 ": "
                 vParamSumm[mi] FORMAT "->>>,>>>,>>>,>>9.99"
                 SKIP.
          END.
          OUTPUT STREAM out_s CLOSE.
       END.

   END.
   ELSE
   DO:
      /* для всех течений договора, кроме тех, которые открыты позже iDate
         или закрыты ранее iDate
      */
      IF mIfPutPtot THEN
      DO:
          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
                  "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
                  ".  Вычисление Срочной задолженности по договору за "
                  STRING(iDate, "99/99/9999") + "."
                  SKIP.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
             ".  Договор имеет тип 'Течение'. Расчет величины Срочной задолженности будет выполнен по подчиненным договорам."
             SKIP.
          OUTPUT STREAM out_s CLOSE.
      END.

      FOR EACH b-loan WHERE
               b-loan.contract = iContract
           AND b-loan.cont-code BEGINS iContCode
           AND NUM-ENTRIES(b-loan.cont-code, " ") = 2
           AND ENTRY(1, b-loan.cont-code, " ")    = iContCode
           AND b-loan.open-date <= iDate
      NO-LOCK:

         IF b-loan.close-date <> ? AND
            b-loan.close-date <= iDate
         THEN
            NEXT.

         vRes = vRes +  LnGoodDebt(b-loan.contract,
                                   b-loan.cont-code,
                                   iDate,
                                   iCurrency).

      END. /*FOR EACH*/

   END.

   mResult = CurrRound(vRes,iCurrency).

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(vDoc-ref, " ") = 2
              AND mResult = 0) THEN
   DO:
       OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " vDoc-ref FORMAT "X(22)"
          ".  Срочная задолженность по договору в валюте "
          iCurrency FORMAT "x(3)"
          ": "
          mResult FORMAT "->>>,>>>,>>>,>>9.99"
          SKIP.
       OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnBadDebt
  Name       : Просроченная задолженность
  Purpose    : возвращает величину просроченной задолженности по договору
               за указанную дату. Для договоров с течениями будет возвращена
               общая сумма просроченной задолженности по всем траншам.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnBadDebt RETURNS DECIMAL (INPUT iContract AS CHAR,
                                    INPUT iContCode AS CHAR,
                                    INPUT iDate     AS DATE,
                                    INPUT iCurrency AS CHAR).

   DEF VAR mPrincipalSumm AS DEC NO-UNDO.
   DEF VAR mGoodDebtSumm  AS DEC NO-UNDO.
   DEF VAR mBadDebtSumm   AS DEC NO-UNDO.

   DEFINE BUFFER b-loan FOR loan.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   ASSIGN
      mPrincipalSumm = LnPrincipal(iContract,iContCode,iDate,iCurrency)
      mGoodDebtSumm  = LnGoodDebt (iContract,iContCode,iDate,iCurrency)
      mBadDebtSumm   = mPrincipalSumm - mGoodDebtSumm
      .

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
              AND mPrincipalSumm = 0
              AND mGoodDebtSumm = 0)  THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Вычисление Просроченой задолженности по договору за "
      STRING(iDate, "99/99/9999") + "."
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  [Просроченная задолженность] = [Общая задолженность] - [Срочная задолженность]"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      "."
      mBadDebtSumm   FORMAT "->>>,>>>,>>>,>>9.99"
      " = "
      mPrincipalSumm FORMAT "->>>,>>>,>>>,>>9.99"
      " - "
      mGoodDebtSumm  FORMAT "->>>,>>>,>>>,>>9.99"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Просроченная задолженность по договору в валюте "
      iCurrency    FORMAT "x(3)"
      ": "
      mBadDebtSumm FORMAT "->>>,>>>,>>>,>>9.99"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mBadDebtSumm.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnSyndLoan
  Name       : Признак синдицированной ссуды
  Purpose    : возвращает признак договора - является ли он синдицированной
               ссудой.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnSyndLoan RETURNS LOGICAL (INPUT iContract AS CHAR,
                                     INPUT iContCode AS CHAR).
   DEFINE BUFFER b-loan FOR loan.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN FALSE.
   END.

   IF b-loan.contract = "Кредит" AND
      GetXAttrValue("loan",iContract + ',' + iContCode,"СиндКред") EQ "Синд"
   THEN
      RETURN TRUE.  /* договор является синдицированной ссудой */
   ELSE
   IF NUM-ENTRIES(iContCode, " ") = 2 THEN
      RETURN LnSyndLoan(iContract,ENTRY(1,iContCode," ")).
   ELSE
      RETURN FALSE.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnOptionClause
  Name       : Признак наличия опционной оговорки
  Purpose    : возвращает признак опционной оговорки по депозитному договору.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnOptionClause RETURNS LOGICAL (INPUT iContract AS CHAR,
                                         INPUT iContCode AS CHAR).

   DEF BUFFER b-loan FOR loan.
   DEF BUFFER x-loan FOR loan.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF NUM-ENTRIES(iContCode, " ") = 2 AND
      CAN-FIND( FIRST x-loan WHERE
                      x-loan.cont-type = "Течение"
                  AND x-loan.contract  = iContract
                  AND x-loan.cont-code = ENTRY(1,iContCode, " "))
   THEN
      RETURN (LnOptionClause(iContract,ENTRY(1,iContCode, " "))).
   ELSE
      RETURN (GetXAttrValue("loan",iContract + ',' + iContCode,"Option") EQ "Да").

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnPartAmt
  Name       : Сумма участия
  Purpose    : возвращает для кредитного договора общую сумму средств,
               привлеченных по этому договору от участников синдицированного
               кредита.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnPartAmt RETURNS DECIMAL (INPUT iContract AS CHAR,
                                    INPUT iContCode AS CHAR,
                                    INPUT iDate     AS DATE,
                                    INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan     FOR loan.
   DEFINE BUFFER b-loan-up  FOR loan.

   DEFINE VAR Result-Sum   AS DEC INIT 0 NO-UNDO.
   DEFINE VAR mContract    AS CHAR NO-UNDO.
   DEFINE VAR mContCode    AS CHAR NO-UNDO.
   DEFINE VAR mIsSyndLoan  AS LOG  NO-UNDO.
   DEFINE VAR mSyndLoan    AS CHAR NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN 0.00.
   END.

   DEFINE VARIABLE vDoc-ref AS CHAR NO-UNDO.
   DEFINE VARIABLE vDoc-ref1 AS CHAR NO-UNDO.
   vDoc-ref = b-loan.doc-ref .

   IF NOT LnSyndLoan(iContract,iContCode) THEN  RETURN 0.00.

   /* обрабатываются все депозитные договора, которые имеют ссылку на текущий
      обрабатываемый кредитный договор, не имеют опционной оговорки и не имеют
      вышестоящего договора, который имеет ссылку на тот же кредитный договор
   */

   FOR EACH signs WHERE
      signs.file-name = "loan" AND
      signs.code = "SyndLoanId" AND
      signs.surrogate BEGINS "Депоз"
   NO-LOCK:

      mSyndLoan = GetXAttrValue("loan",signs.surrogate,"SyndLoanId").

      IF mSyndLoan <> iContCode THEN NEXT.

      FIND FIRST b-loan WHERE b-loan.contract = ENTRY(1,signs.surrogate) AND
                        b-loan.cont-code      = ENTRY(2,signs.surrogate)
                        NO-LOCK NO-ERROR.
      IF AVAIL b-loan THEN DO:

         IF mIfPutPtot THEN
         DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
            "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
            ".  Найден пассивный договор, участвующий в синдицированном кредите: "
            b-loan.cont-code FORMAT "x(22)"
            SKIP.
         OUTPUT STREAM out_s CLOSE.
         END.

         ASSIGN
            mIsSyndLoan = mSyndLoan = iContCode
            mContract   = b-loan.Contract
            mContCode   = b-loan.Cont-Code
         .

         IF     mIfPutPtot
            AND LnOptionClause(mContract,mContCode) THEN
         DO:
            OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
            PUT STREAM out_s UNFORMATTED
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  Договор "
               b-loan.doc-ref FORMAT "X(22)"
               " имеет признак опционной оговорки. Основной долг по договору не входит в сумму участия."
               SKIP.
            OUTPUT STREAM out_s CLOSE.
         END.

         IF mIsSyndLoan AND
            (NOT (LnOptionClause(mContract,mContCode)) )
         THEN
         DO:
            IF NUM-ENTRIES(b-loan.cont-code, " ") = 2
               AND
               CAN-FIND( FIRST b-loan-up
                            WHERE
                               b-loan-up.cont-type = "Течение" AND
                               b-loan-up.contract  = b-loan.contract AND
                               b-loan-up.cont-code = ENTRY(1,b-loan.cont-code, " ")
                       )
            THEN
            DO:
               FIND FIRST b-loan-up
                        WHERE b-loan-up.cont-type = "Течение" AND
                              b-loan-up.contract  = b-loan.contract AND
                              b-loan-up.cont-code = ENTRY(1,b-loan.cont-code, " ")
                     NO-LOCK NO-ERROR.

               IF GetXAttrValue("loan",b-loan-up.contract + ","
                                     + b-loan-up.cont-code,"SyndLoanId") =
                  iContCode THEN NEXT.
            END.

            Result-Sum = Result-Sum + LnPrincipal(b-loan.contract,
                                                  b-loan.cont-code,
                                                  iDate,
                                                  iCurrency
                                                 ).
         END.
      END.
   END. /*FOR EACH*/

   vDoc-ref1 = IF AVAIL b-loan THEN b-loan.doc-ref
                               ELSE "".
   IF mIfPutPtot THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " vDoc-ref1 FORMAT "X(22)"
      ".  Сумма участия договора "
      vDoc-ref FORMAT "X(22)"
      " в валюте "
      iCurrency  FORMAT "x(3)"
      ": "
      Result-Sum FORMAT "->>>,>>>,>>>,>>9.99"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   RETURN Result-Sum.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnPersRisk
  Name       : Признак наличия индивидуальных коэффициентов резервирования
               для траншей
  Purpose    : возвращает признак наличия индивидуальных коэффициентов
               резервирования по траншам кредитного договора с течениями.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnPersRisk RETURNS LOGICAL (INPUT iContract AS CHAR,
                                     INPUT iContCode AS CHAR,
                                     INPUT iDate     AS DATE).
   DEFINE BUFFER b-loan  FOR loan.

   DEF VAR mPrevRsrvRate AS DEC INIT ? NO-UNDO.
   DEF VAR mNextRsrvRate AS DEC INIT ? NO-UNDO.
   DEF VAR vFirst        AS LOG        NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF b-loan.cont-type NE "Течение" THEN RETURN FALSE.

   vFirst = YES.

   FOR EACH b-loan WHERE
            b-loan.contract  = iContract
        AND b-loan.cont-code BEGINS iContCode + " "
        AND b-loan.cont-code <> iContCode
        AND b-loan.open-date <= iDate
   NO-LOCK:

      IF b-loan.close-date <> ? AND b-loan.close-date <= iDate THEN NEXT.

      mNextRsrvRate = LnRsrvRate(b-loan.contract,b-loan.cont-code,iDate).

      IF vFirst THEN mPrevRsrvRate = mNextRsrvRate.

      IF mNextRsrvRate <> mPrevRsrvRate THEN RETURN YES.

      ASSIGN
         mPrevRsrvRate = mNextRsrvRate
         vFirst        = NO
         .

   END. /*FOR EACH*/

   RETURN NO.

END FUNCTION.


/*---------------------------------------------------------------------------
  Function   : LnRsrvCheckType
  Name       : Проверка по роли счета ведения резерва на конкретном договоре
  Purpose    : Проверяет - должен ли вестись учет резерва в параметрах договора

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iType       - роль счета резерва
  Notes      :
  ---------------------------------------------------------------------------*/

FUNCTION LnRsrvCheckType RETURNS LOGICAL (INPUT iContract AS CHAR,
                                          INPUT iContCode AS CHAR,
                                          INPUT iType     AS CHAR).

   DEF BUFFER b-loan    FOR loan.
   DEF BUFFER loan      FOR loan.
   DEF BUFFER loan-cond FOR loan-cond.

   DEF VAR oResVer AS LOGICAL NO-UNDO INIT FALSE .
   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF b-loan.cont-type = "Течение" AND
      NOT CAN-FIND(FIRST loan-cond WHERE loan-cond.contract  = b-loan.contract
                                     AND loan-cond.cont-code = b-loan.cont-code)
                                     AND GetXAttrInit(b-loan.class-code, "NOLoanCond") NE "Да"
   THEN
   DO:
      IF mIfPutPtot THEN
      DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
            "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
            ".  Договор имеет тип 'Течение' и не имеет условий. Для договоров такого вида Резерв считается равным нулю."
            SKIP.
         OUTPUT STREAM out_s CLOSE.
      END.
      RETURN FALSE.
   END.

   /* для транша , если oResVer , то не проверяем rel_type */
   IF NUM-ENTRIES(b-loan.doc-ref, " ") = 2
   THEN DO:
      RUN GetVerifyRelType IN THIS-PROCEDURE  (OUTPUT oResVer).
      IF oResVer
      THEN
         RETURN TRUE.
   END.

   /* роль iType не содержится в нач.значении реквизита rel_type
      класса договора */
   IF NOT CAN-DO( GetXAttrInit(b-loan.class-code,"rel_type"), iType)
   THEN
   DO:
      IF mIfPutPtot
        AND NOT(mIfPutNotNull
                AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
      DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
            "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
            ".  Класс договора "
            b-loan.class-code FORMAT "x(12)"
            ". Для договоров этого класса Резерв (" + iType + ") считается равным нулю (rel_type)."
            SKIP.
         OUTPUT STREAM out_s CLOSE.
      END.
      RETURN FALSE.
   END.

   IF INDEX(b-loan.cont-code," ") <> 0 THEN
   DO:
      FOR EACH loan WHERE
               loan.contract = b-loan.contract
           AND loan.cont-code = ENTRY(1,b-loan.cont-code," ")
      NO-LOCK,
         FIRST loan-cond WHERE
               loan-cond.contract  = loan.contract
           AND loan-cond.cont-code = loan.cont-code
      NO-LOCK:
         IF CAN-DO(GetXAttrInit(loan.class-code,"rel_type"), iType)
            AND GetXAttrInit(b-loan.class-code,"NOLoanCond") NE "Да"
         THEN
         DO:
            IF mIfPutPtot
               AND NOT mIfPutNotNull THEN
            DO:
               OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
               PUT STREAM out_s UNFORMATTED
                  "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
                  ".  Для вышестоящего договора "
                  loan.doc-ref FORMAT "X(22)"
                  " класса "
                  loan.class-code FORMAT "x(12)"
                  " установлен расчет резерва (rel_type)"
                  SKIP
                  "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
                  ".  Для текущего договора "
                  b-loan.doc-ref FORMAT "X(22)"
                  " Резерв (" + iType + ") по этой причине считается равным нулю."
                  SKIP.
               OUTPUT STREAM out_s CLOSE.
            END.
            RETURN FALSE.
         END.
         LEAVE.
      END.
   END.

   RETURN TRUE.

END FUNCTION.


/*---------------------------------------------------------------------------
  Function   : LnRsrvCheck
  Name       : Проверка ведения резерва на конкретном договоре
  Purpose    : Проверяет - должен ли вестись учет резерва в параметрах договора

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
  Notes      :
  ---------------------------------------------------------------------------*/

FUNCTION LnRsrvCheck RETURNS LOGICAL (INPUT iContract AS CHAR,
                                      INPUT iContCode AS CHAR).

   RETURN LnRsrvCheckType (iContract,iContCode,"КредРез").

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnCalcRsrv
  Name       : Расчетный резерв
  Purpose    : возвращает величину расчетного резерва по договору. Если на
               договоре не ведется учет резерва, то функция возвращает ноль.
               По договорам с течениями расчетный резерв будет определен для
               всех траншей договора.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnCalcRsrv RETURNS DECIMAL (INPUT iContract AS CHAR,
                                     INPUT iContCode AS CHAR,
                                     INPUT iDate     AS DATE,
                                     INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan    FOR loan.
   DEF BUFFER loan      FOR loan.
   DEF BUFFER loan-cond FOR loan-cond.

   DEF VAR mSyndLoan  AS LOG NO-UNDO.           /* признак синдицированной ссуды */
   DEF VAR mRsrvRate  AS DEC INIT 0 NO-UNDO.    /* коэффициент резервирования */
   DEF VAR mCalcRsrv  AS DEC INIT 0 NO-UNDO.    /* расчетный резерв по соглашению */
   DEF VAR mBasicDebt AS DEC INIT 0 NO-UNDO.    /* основной долг по соглашению */
   DEF VAR mPartAmt   AS DEC INIT 0 NO-UNDO.    /* сумма участия по соглашению */
   DEF VAR mCalcRsrvBase AS DEC INIT 0 NO-UNDO. /* база расчета резерва */
   DEF VAR mResult    AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).
   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ? .
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2)  THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Вычисление общей величины Расчетного резерва за "
      STRING(iDate, "99/99/9999") + "."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   IF LnRsrvCheck(iContract, iContCode) = FALSE THEN RETURN 0.00.

   {i254.i &SetCalcRsrv = "YES"}

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnCalcRsrvTransh
  Name       : Расчетный резерв для траншей
  Purpose    : возвращает величину расчетного резерва по договору. Если на
               договоре не ведется учет резерва, то функция возвращает ноль.
               Для договоров-соглашений(тип Течение) возвращает 0.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnCalcRsrvTransh RETURNS DECIMAL (INPUT iContract AS CHAR,
                                           INPUT iContCode AS CHAR,
                                           INPUT iDate     AS DATE,
                                           INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan    FOR loan.
   DEF BUFFER loan      FOR loan.
   DEF BUFFER loan-cond FOR loan-cond.

   DEF VAR mSyndLoan  AS LOG NO-UNDO.           /* признак синдицированной ссуды */
   DEF VAR mRsrvRate  AS DEC INIT 0 NO-UNDO.    /* коэффициент резервирования */
   DEF VAR mCalcRsrv  AS DEC INIT 0 NO-UNDO.    /* расчетный резерв по соглашению */
   DEF VAR mBasicDebt AS DEC INIT 0 NO-UNDO.    /* основной долг по соглашению */
   DEF VAR mPartAmt   AS DEC INIT 0 NO-UNDO.    /* сумма участия по соглашению */
   DEF VAR mCalcRsrvBase AS DEC INIT 0 NO-UNDO. /* база расчета резерва */
   DEF VAR mResult    AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Вычисление общей величины Расчетного резерва за "
      STRING(iDate, "99/99/9999") + " (Режим: расчет по траншам)."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   IF b-loan.cont-type = "Течение" THEN
   DO:
      IF mIfPutPtot THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Договор имеет тип 'Течение'. Для договоров такого вида Расчетный резерв считается равным нулю."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      RETURN 0.00.
   END.

   {i254.i &SetCalcRsrv = "YES" &SetNotRound = "YES"}

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnPledge
  Name       : Стоимость объекта обеспечения
  Purpose    : возвращает оценочную стоимость объекта обеспечения без учета
               значений коэффициента снижения стоимости и индекса качества
               обеспечения.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iIdnt       - идентификатор
               iEndDate    - срок
               iNN         - ?
               iDate       - дата операции
               iDateRate   - дата пересчета курса
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnPledge RETURNS DECIMAL (INPUT iContract AS CHAR,
                                   INPUT iContCode AS CHAR,
                                   INPUT iIdnt     AS INT64,
                                   INPUT iEndDate  AS DATE,
                                   INPUT iNN       AS INT64,
                                   INPUT iDate     AS DATE,
                                   INPUT iDateRate AS DATE,
                                   INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan      FOR loan.
   DEF BUFFER b-term-obl  FOR term-obl.
   DEF BUFFER b-loan-acct FOR loan-acct.
   DEF BUFFER b-acct      FOR acct.

   DEF VAR acct-ost  AS DEC INIT 0 NO-UNDO. /* остаток на счете */
   DEF VAR mObjCost  AS DEC NO-UNDO.        /* стоимость объекта обеспечения */
   DEF VAR vAcctType AS CHAR NO-UNDO.
   DEF VAR vTmpStr   AS CHAR NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   /* определяем способ оценки объекта обеспечения */
   FIND FIRST b-term-obl WHERE
              b-term-obl.contract  = b-loan.contract
          AND b-term-obl.cont-code = b-loan.cont-code
          AND b-term-obl.idnt      = iIdnt
          AND b-term-obl.end-date  = iEndDate
          AND b-term-obl.nn        = iNN
      NO-LOCK NO-ERROR.

   IF NOT AVAIL b-term-obl THEN DO:
      IF mIfPutPtot THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Ошибка      Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Объект обеспечения не найден."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      RETURN 0.0.
   END.

   IF b-term-obl.sop-date <= iDate THEN RETURN 0.00.

   IF b-term-obl.fop-offbal = 0 THEN
   DO:
      /* способ оценки объекта обеспечения - "ПО ОСТАТКУ СЧЕТА" */

      /* поиск счета, связанного с объектом обеспечения */

      vTmpStr = GetXAttrValueEx("term-obl",
                                   iContract + ","
                                 + iContCode + ","
                                 + STRING(b-term-obl.idnt) + ","
                                 + STRING(b-term-obl.end-date) + ","
                                 + STRING(b-term-obl.nn),
                                   "НомерПП",
                                   "0").
      vAcctType =    GetXAttrValue("term-obl",
                                   iContract + ","
                                 + iContCode + ","
                                 + STRING(b-term-obl.idnt) + ","
                                 + STRING(b-term-obl.end-date) + ","
                                 + STRING(b-term-obl.nn),
                                   "ВидДогОб")
                   + IF vTmpStr = "0" THEN "" ELSE vTmpStr.


      RUN RE_L_ACCT IN h_Loan (iContract,
                               iContCode,
                               vAcctType,
                               iDate,
                               BUFFER b-loan-acct).

      IF NOT AVAIL b-loan-acct THEN DO:
         IF mIfPutPtot THEN
         DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
            "Ошибка      Договор: " b-loan.doc-ref FORMAT "X(22)"
            ".  Не найден счет по роли "
            vAcctType FORMAT "x(12)"
            SKIP.
         OUTPUT STREAM out_s CLOSE.
         END.
         RETURN 0.00.
      END.

      FIND FIRST b-acct WHERE
                 b-acct.acct     = b-loan-acct.acct
             AND b-acct.currency = b-loan-acct.currency
      NO-LOCK NO-ERROR.

      IF NOT AVAIL b-acct THEN DO:
         IF mIfPutPtot THEN
         DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
            "Ошибка      Договор: " b-loan.doc-ref FORMAT "X(22)"
            ".  Не найден счет " b-loan-acct.acct FORMAT "X(20)"
             " в валюте " b-loan-acct.currency
            SKIP.
         OUTPUT STREAM out_s CLOSE.
         END.
         RETURN 0.00.
      END.

      /* вычисляем остаток в валюте счета */
      RUN acct-pos IN h_base (b-loan-acct.acct, b-acct.currency,
                              iDate, iDate, CHR(251)).
      acct-ost = (IF b-acct.currency = "" THEN sh-bal ELSE sh-val ).

      IF b-acct.side = "П" THEN DO:
         acct-ost = acct-ost * -1 .
         IF acct-ost < 0 THEN RETURN 0.00. /* нарушен режим остатка по счету */
      END.

      /* приводим к валюте договора */
      IF b-loan-acct.currency <> iCurrency THEN
         ASSIGN
            acct-ost = CurToCur("учетный",                                    /*тип курса*/
                                b-loan-acct.currency,                         /*из валюты*/
                                iCurrency,                                    /*в валюту*/
                                IF iDateRate EQ ? THEN iDate ELSE iDateRate,  /*дата*/
                                acct-ost)                                     /*переводимая сумма*/

            acct-ost = CurrRound ( acct-ost, iCurrency ).

      IF mIfPutPtot
         AND NOT(mIfPutNotNull
                 AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
                 AND acct-ost = 0)  THEN
      DO:
        OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
        PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Объект обеспечения "
          GetXAttrValueEx ("term-obl",
                           iContract + "," + iContCode + ",5,"
                         + STRING(b-term-obl.end-date) + ","
                         + STRING(b-term-obl.nn),
                           "НомДогОб",
                           "") FORMAT "x(22)"
          " "
          STRING(b-term-obl.fop-date, "99/99/9999")
          " / "
          b-term-obl.amt-rub  FORMAT "->>>>,>>>,>>>,>>9.99"
          " "
          b-term-obl.currency FORMAT "xxx"
          " / "
          GetXAttrValueEx ("term-obl",
                           iContract + "," + iContCode + ",5,"
                         + STRING(b-term-obl.end-date) + ","
                         + STRING(b-term-obl.nn),
                           "ВидДогОб",
                           "") FORMAT "x(16)"
          " "
          INT64(GetXAttrValueEx ("term-obl",
                           iContract + "," + iContCode + ",5,"
                         + STRING(b-term-obl.end-date) + ","
                         + STRING(b-term-obl.nn),
                           "НомерПП",
                           "")) FORMAT "->,>>>,>>9"
          " (id: "
          b-term-obl.idnt FORMAT "->,>>>,>>9"
          " "
          STRING(b-term-obl.end-date, "99/99/9999")
          " "
          b-term-obl.nn FORMAT "->,>>>,>>9"
          SKIP
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Расчет стоимости объекта обеспечения за "
          STRING(iDate, "99/99/9999") + "."
          SKIP.

        PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Способ оценки: По остатку счета. "
         SKIP
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ". Счет: "
         b-loan-acct.acct  FORMAT "x(25)"
         ". Эквивалент остатка в валюте "
         iCurrency FORMAT "x(3)"
         ": "
         acct-ost  FORMAT "->>>>,>>>,>>>,>>9.99"
         SKIP.
        OUTPUT STREAM out_s CLOSE.
      END.

      RETURN acct-ost.
   END.

   ELSE
   DO:
      IF b-term-obl.fop-offbal = 1 OR b-term-obl.fop-offbal = 2 THEN
      DO:
         /* способ оценки объекта обеспечения - "ПО СПРАВЕДЛИВОЙ СТОИМОСТИ"*/
         IF b-term-obl.fop-offbal = 1 THEN
         DO:
            /* ищем запись о текущей стоимости объекта обеспечения */
            FIND LAST instr-rate
               WHERE  instr-rate.instr-cat  = "collateral_value" AND
                      instr-rate.rate-type  = "fair_value"       AND
                      instr-rate.instr-code = iContract + "," + iContCode + ","
                                            + STRING(iIdnt) + ","
                                            + STRING(iEndDate) + ","
                                            + STRING(iNN)
                      AND
                      instr-rate.since <= iDate
            /* USE-INDEX instr-date */
               NO-LOCK NO-ERROR.

            IF NOT AVAIL instr-rate THEN  RETURN 0.00.
         END.

         /* способ оценки объекта обеспечения - "ПО РЫНОЧНОЙ СТОИМОСТИ" */
         IF b-term-obl.fop-offbal = 2 THEN
         DO:
            /* поиск рыночной цены финансового инструмента, на который
               ссылается объект обеспечения
            */
            FIND LAST instr-rate WHERE
                      instr-rate.instr-cat  = b-term-obl.cor-acct  AND
                      instr-rate.rate-type  = b-term-obl.suser-id  AND
                      instr-rate.instr-code = b-term-obl.fuser-id  AND
                      instr-rate.since <= iDate
                 USE-INDEX instr-date
                 NO-LOCK NO-ERROR.

            IF NOT AVAIL instr-rate THEN  RETURN 0.00.
         END.

         /* стоимость объекта обеспечения */
         ASSIGN
            mObjCost = instr-rate.rate-instr / instr-rate.per * b-term-obl.sop-offbal
            mObjCost = CurrRound ( mObjCost, b-term-obl.currency ).

         /* если необходимо приводим к валюте договора */
         IF b-term-obl.currency <> iCurrency THEN
            ASSIGN
               mObjCost = CurToCur("учетный",                                    /*тип курса*/
                                   b-term-obl.currency,                          /*из валюты*/
                                   iCurrency,                                    /*в валюту*/
                                   IF iDateRate EQ ? THEN iDate ELSE iDateRate,  /*дата*/
                                   mObjCost)                                     /*переводимая сумма*/

               mObjCost = CurrRound ( mObjCost, iCurrency ).

         IF mIfPutPtot
            AND NOT(mIfPutNotNull
                    AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
                    AND mObjCost = 0) THEN
         DO:
           OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
           PUT STREAM out_s UNFORMATTED
              "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
              ".  Объект обеспечения "
              GetXAttrValueEx ("term-obl",
                               iContract + "," + iContCode + ",5,"
                             + STRING(b-term-obl.end-date) + ","
                             + STRING(b-term-obl.nn),
                               "НомДогОб",
                               "") FORMAT "x(22)"
              " "
              STRING(b-term-obl.fop-date, "99/99/9999")
              " / "
              b-term-obl.amt-rub  FORMAT "->>>>,>>>,>>>,>>9.99"
              " "
              b-term-obl.currency FORMAT "xxx"
              " / "
              GetXAttrValueEx ("term-obl",
                               iContract + "," + iContCode + ",5,"
                             + STRING(b-term-obl.end-date) + ","
                             + STRING(b-term-obl.nn),
                               "ВидДогОб",
                               "") FORMAT "x(16)"
              " "
              INT64(GetXAttrValueEx ("term-obl",
                               iContract + "," + iContCode + ",5,"
                             + STRING(b-term-obl.end-date) + ","
                             + STRING(b-term-obl.nn),
                               "НомерПП",
                               "")) FORMAT "->,>>>,>>9"
              " (id: "
              b-term-obl.idnt FORMAT "->,>>>,>>9"
              " "
              STRING(b-term-obl.end-date, "99/99/9999")
              " "
              b-term-obl.nn FORMAT "->,>>>,>>9"
              SKIP
              "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
              ".  Расчет стоимости объекта обеспечения за "
              STRING(iDate, "99/99/9999") + "."
              SKIP.
           OUTPUT STREAM out_s CLOSE.
         END.

         IF b-term-obl.fop-offbal = 1
            AND mIfPutPtot
            AND NOT(mIfPutNotNull
                    AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
                    AND mObjCost = 0) THEN
         DO:
            OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
            PUT STREAM out_s UNFORMATTED
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  Способ оценки: По индивидуальной стоимости."
               SKIP
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  [Стоим. обесп.] = [Цена за кол-во единиц] / [Кол-во единиц] * [Кол-во объектов обеспечения]"
               SKIP
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  "
               mObjCost FORMAT "->>>>,>>>,>>>,>>9.99"
               "("
               b-term-obl.currency FORMAT "x(3)"
               ") = "
               instr-rate.rate-instr FORMAT ">>>,>>>,>>9.99999"
               " / "
               instr-rate.per FORMAT ">>>,>>9"
               " * "
               b-term-obl.sop-offbal FORMAT ">>9"
               SKIP
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  Эквивалент в валюте "
               iCurrency FORMAT "x(3)"
               ": "
               mObjCost  FORMAT "->>>>,>>>,>>>,>>9.99"
               SKIP.
            OUTPUT STREAM out_s CLOSE.
         END.

         IF b-term-obl.fop-offbal = 2
            AND mIfPutPtot
            AND NOT(mIfPutNotNull
                    AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
                    AND mObjCost = 0) THEN
         DO:
            OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
            PUT STREAM out_s UNFORMATTED
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  Способ оценки: По котировке финансового инструмента."
               SKIP
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  Тип ФИ: "
               b-term-obl.cor-acct FORMAT "x(25)"
               ". Код ФИ: "
               b-term-obl.fuser-id FORMAT "x(10)"
               ". Тип котировки: "
               b-term-obl.suser-id FORMAT "x(10)"
               SKIP
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  [Стоим. обесп.] = [Цена за кол-во единиц] / [Кол-во единиц] * [Кол-во объектов обеспечения]"
               SKIP
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  "
               mObjCost FORMAT "->>>>,>>>,>>>,>>9.99"
               "("
               b-term-obl.currency FORMAT "x(3)"
               ") = "
               instr-rate.rate-instr FORMAT ">>>,>>>,>>9.99999"
               " / "
               instr-rate.per FORMAT ">>>,>>9"
               " * "
               b-term-obl.sop-offbal FORMAT ">>9"
               SKIP
               "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
               ".  Эквивалент в валюте "
               iCurrency FORMAT "x(3)"
               ": "
               mObjCost  FORMAT "->>>>,>>>,>>>,>>9.99"
               SKIP.
            OUTPUT STREAM out_s CLOSE.
         END.

         RETURN mObjCost.

      END. /* fop-offbal = 1 or fop-offbal = 2 */

   END.

   RETURN 0.00.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : Get_QualityGar
  Name       : Значение категории качества обеспечения
  Purpose    : Получение значения категории качеста обеспечения, действующую
               на передаваемую дату
  Parameters : iFileName  - таблица
               iSurrogate - суррогат договора обеспечения
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION Get_QualityGar RETURNS CHAR (INPUT iFileName  AS CHAR,
                                      INPUT iSurrogate AS CHAR,
                                      INPUT iSince     AS DATE).

   DEF BUFFER xterm-obl FOR term-obl.

   DEF VAR vReturn AS CHAR NO-UNDO INIT ?.
   DEF VAR vCRSurr AS CHAR NO-UNDO.

   /* Ищем нужный term-obl */
   FIND FIRST xterm-obl WHERE xterm-obl.contract  EQ ENTRY(1,iSurrogate)
                          AND xterm-obl.cont-code EQ ENTRY(2,iSurrogate)
                          AND xterm-obl.idnt      EQ INT64(ENTRY(3,iSurrogate))
                          AND xterm-obl.end-date  EQ DATE(ENTRY(4,iSurrogate))
                          AND xterm-obl.nn        EQ INT64(ENTRY(5,iSurrogate))
      NO-LOCK NO-ERROR.

   IF AVAIL xterm-obl THEN
   DO:
      /* Ищем comm-rate */
      FOR EACH comm-rate WHERE comm-rate.commission EQ "КачОбеспеч"
                           AND comm-rate.acct       EQ "0"
                           AND comm-rate.currency   EQ xterm-obl.currency
                           AND comm-rate.kau        EQ iSurrogate
                           AND comm-rate.min-value  EQ 0
                           AND comm-rate.period     EQ 0
                           AND comm-rate.since      LE iSince USE-INDEX kau NO-LOCK BY comm-rate.since DESCENDING:
          LEAVE.
      END.
      /* Если он есть, то определяем значение Категории качества
      ** по соответствующему ДР */
      IF AVAIL comm-rate THEN
      DO:
         vReturn = GetXAttrValueEx("comm-rate",STRING(comm-rate.comm-rate-id),"КачОбеспеч","?").
      END.
   END.

   RETURN vReturn.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : Get_VidObespech
  Name       : Значение вида обеспечения по категории качества
  Purpose    : Получение значения вида обеспечения, действующую
               на передаваемую дату
  Parameters : iSurrogate - суррогат договора обеспечения
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION Get_VidObespech RETURNS CHAR (INPUT iSurrogate AS CHAR,
                                       INPUT iSince     AS DATE).

   DEF BUFFER xterm-obl FOR term-obl.

   DEF VAR vReturn AS CHAR NO-UNDO INIT "?".
   DEF VAR vCRSurr AS CHAR NO-UNDO.

   /* Ищем нужный term-obl */
   FIND FIRST xterm-obl WHERE xterm-obl.contract  EQ ENTRY(1,iSurrogate)
                          AND xterm-obl.cont-code EQ ENTRY(2,iSurrogate)
                          AND xterm-obl.idnt      EQ INT64(ENTRY(3,iSurrogate))
                          AND xterm-obl.end-date  EQ DATE(ENTRY(4,iSurrogate))
                          AND xterm-obl.nn        EQ INT64(ENTRY(5,iSurrogate))
      NO-LOCK NO-ERROR.

   IF AVAIL xterm-obl THEN
   DO:
      /* Ищем comm-rate */
      FOR EACH comm-rate WHERE comm-rate.commission EQ "КачОбеспеч"
                           AND comm-rate.acct       EQ "0"
                           AND comm-rate.currency   EQ xterm-obl.currency
                           AND comm-rate.kau        EQ iSurrogate
                           AND comm-rate.min-value  EQ 0
                           AND comm-rate.period     EQ 0
                           AND comm-rate.since      LE iSince USE-INDEX kau NO-LOCK BY comm-rate.since DESCENDING:
          LEAVE.
      END.
      /* Если он есть, то определяем значение вида обеспечения
      ** по соответствующему ДР */
      IF AVAIL comm-rate THEN
      DO:
         vReturn = GetXAttrValueEx("comm-rate",STRING(comm-rate.comm-rate-id),"Ф117_ВидОб","?").
      END.
   END.

   RETURN vReturn.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : GetLast_QualityGar
  Name       : Значение категории качества обеспечения
  Purpose    : Получение значения категории качеста обеспечения, последнего
               установленного
  Parameters : iFileName  - таблица
               iSurrogate - суррогат договора обеспечения
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION GetLast_QualityGar RETURNS CHAR (INPUT iFileName  AS CHAR,
                                          INPUT iSurrogate AS CHAR).

   DEF BUFFER xterm-obl FOR term-obl.

   DEF VAR vReturn AS CHAR NO-UNDO INIT "?".
   DEF VAR vCRSurr AS CHAR NO-UNDO.

   /* Ищем нужный term-obl */
   FIND FIRST xterm-obl WHERE xterm-obl.contract  EQ ENTRY(1,iSurrogate)
                          AND xterm-obl.cont-code EQ ENTRY(2,iSurrogate)
                          AND xterm-obl.idnt      EQ INT64(ENTRY(3,iSurrogate))
                          AND xterm-obl.end-date  EQ DATE(ENTRY(4,iSurrogate))
                          AND xterm-obl.nn        EQ INT64(ENTRY(5,iSurrogate))
      NO-LOCK NO-ERROR.

   IF AVAIL xterm-obl THEN
   DO:
      /* Ищем comm-rate */
      FOR EACH comm-rate WHERE comm-rate.commission EQ "КачОбеспеч"
                           AND comm-rate.acct       EQ "0"
                           AND comm-rate.currency   EQ xterm-obl.currency
                           AND comm-rate.kau        EQ iSurrogate
                           AND comm-rate.min-value  EQ 0
                           AND comm-rate.period     EQ 0 USE-INDEX kau NO-LOCK BY comm-rate.since DESCENDING:
          LEAVE.
      END.
      /* Если он есть, то определяем значение Категории качества
      ** по соответствующему ДР */
      IF AVAIL comm-rate THEN
      DO:
         vReturn = GetXAttrValueEx("comm-rate",STRING(comm-rate.comm-rate-id),"КачОбеспеч","?").
      END.
   END.

   RETURN vReturn.
END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : Set_QualityGar
  Name       : Установка категории качества по обеспечению
  Purpose    : Записывает в нужное место информацию о категории качества
               обеспечения
  Parameters : iFileName  - таблица
               iSurrogate - суррогат договора обеспечения
               iValue     - значение категории качества для записи
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION Set_QualityGar RETURNS LOGICAL (INPUT iFileName  AS CHAR,
                                         INPUT iSurrogate AS CHAR,
                                         INPUT iValue     AS CHAR).

    DEF BUFFER xterm-obl FOR term-obl.
    DEF BUFFER comm-rate FOR comm-rate. /* Локализация буфера. */

    DEF VAR vReturn  AS LOG    NO-UNDO.
    DEF VAR vCRSurr  AS CHAR   NO-UNDO.
    DEF VAR vComRate AS ROWID  NO-UNDO. /* ROWID comm-rate. */

    /* Ищем нужный term-obl */
    FIND FIRST xterm-obl WHERE xterm-obl.contract  EQ ENTRY(1,iSurrogate)
                           AND xterm-obl.cont-code EQ ENTRY(2,iSurrogate)
                           AND xterm-obl.idnt      EQ INT64(ENTRY(3,iSurrogate))
                           AND xterm-obl.end-date  EQ DATE(ENTRY(4,iSurrogate))
                           AND xterm-obl.nn        EQ INT64(ENTRY(5,iSurrogate))
       NO-LOCK NO-ERROR.

    IF AVAIL xterm-obl THEN
    blck:
    DO ON ERROR UNDO, LEAVE:

       /* Для нужного term-obl создаем comm-rate КачОбеспеч */
       FIND FIRST comm-rate WHERE comm-rate.commission EQ "КачОбеспеч"
                              AND comm-rate.acct       EQ "0"
                              AND comm-rate.currency   EQ xterm-obl.currency
                              AND comm-rate.kau        EQ iSurrogate
                              AND comm-rate.min-value  EQ 0
                              AND comm-rate.period     EQ 0
                              AND comm-rate.since      EQ xterm-obl.fop-date USE-INDEX kau NO-ERROR.
       IF NOT AVAIL comm-rate THEN
       DO:
          CREATE comm-rate.
          ASSIGN
             comm-rate.commission = "КачОбеспеч"
             comm-rate.acct       = "0"
             comm-rate.currency   = xterm-obl.currency
             comm-rate.kau        = iSurrogate
             comm-rate.min-value  = 0
             comm-rate.period     = 0
             comm-rate.since      = xterm-obl.fop-date
             vComRate             = ROWID (comm-rate)
          NO-ERROR.
          IF ERROR-STATUS:ERROR THEN
             LEAVE blck.
          RELEASE comm-rate NO-ERROR.
          IF ERROR-STATUS:ERROR THEN
             LEAVE blck.

          FIND FIRST comm-rate WHERE ROWID (comm-rate) EQ vComRate
          NO-LOCK.

          vCRSurr = GetSurrogateBuffer("comm-rate",(BUFFER comm-rate:HANDLE)).

          /* Записываем class-code */
          IF NOT UpdateSigns("КачОбеспеч",vCRSurr,"class-code","КачОбеспеч",?) THEN
          DO:
             RUN Fill-SysMes IN h_tmess ("","","1","Не удалось обновить ДР class-code на классе comm-rate. Идентификатор записи:" + vCRSurr).
             LEAVE blck.
          END.

       END.
       ELSE
          vCRSurr = GetSurrogateBuffer("comm-rate",(BUFFER comm-rate:HANDLE)).
       /* Записываем в ДР comm-rate'a нужную категорию качества */
       vReturn = UpdateSigns ("КачОбеспеч",vCRSurr,"КачОбеспеч",iValue,?).
    END.

    RETURN vReturn.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnCollateralValueAllEx
  Name       : Сумма обеспечения по ссуде
  Purpose    : Вычисляет общую сумму обеспечения по указанному договору с
               учетом индекса качества обеспечения и коэффициента снижения
               стоимости обеспечения.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iDateRate   - дата пересчета курса
               iCurrency   - код валюты
               iTypeCalc   - "all" - по охват. договору + течениям
                             "one" - по одному конкретному договору
               iFlKK       - учитывать КК обеспечения?
               iFlGQIndex  - учитывать коэф-т снижения стоимости обеспечения?
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnCollateralValueAllEx RETURNS DECIMAL (INPUT iContract  AS CHAR,
                                                 INPUT iContCode AS CHAR,
                                                 INPUT iDate     AS DATE,
                                                 INPUT iDateRate AS DATE,
                                                 INPUT iCurrency AS CHAR,
                                                 INPUT iTypeCalc  AS CHAR,
                                                 INPUT iFlKK      AS LOG,
                                                 INPUT iFlGQIndex AS LOG).
   DEF BUFFER b-loan      FOR loan.
   DEF BUFFER b-term-obl  FOR term-obl.

   DEF VAR mDRGQ     AS CHAR NO-UNDO. /*ДР term-obl.КачествоОбесп */
   DEF VAR mDRInDate AS CHAR NO-UNDO. /*ДР term-obl.ДатаПост */
   DEF VAR mGQIndex  AS DEC  NO-UNDO. /*индекс качества обеспечения*/
   DEF VAR mDecrRate AS DEC  NO-UNDO. /*коэффициент снижения качества обеспечения*/
   DEF VAR mGObjCost AS DEC  NO-UNDO. /*стоимость объекта обеспечения*/
   DEF VAR mGOSumm   AS DEC  NO-UNDO. /*сумма обеспечения по объекту*/
   DEF VAR mGQCode   AS CHAR NO-UNDO.
   DEF VAR mTotSumm  AS DEC  NO-UNDO.
   DEF VAR vFlKK     AS CHAR NO-UNDO.
   
   vFlKK = GetSysConf("Без_учета_категории_качества").
   IF vFlKK EQ "yes" 
   THEN
      iFlKK = NO.
   ASSIGN
      iFlKK      = YES WHEN iFlKK      EQ ?
      iFlGQIndex = YES WHEN iFlGQIndex EQ ?
   .

   {empty tt-Loan}
   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
     OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
     PUT STREAM out_s UNFORMATTED
        "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
        ".  Расчет стоимости обеспечения по договору за "
        STRING(iDate, "99/99/9999") + "."
     SKIP.
     OUTPUT STREAM out_s CLOSE.
   END.
   
   IF b-loan.open-date <= iDate THEN DO:
      CREATE tt-Loan.
      ASSIGN
         tt-Loan.ContCode = b-loan.cont-code
         tt-Loan.DocRef   = b-loan.doc-ref
         .
   END.
      
   IF iTypeCalc  = "all" THEN DO:
      FOR EACH b-loan WHERE
               b-loan.contract  = iContract
           AND b-loan.cont-code = ENTRY(1, iContCode, " ")
           AND b-loan.open-date <= iDate
      NO-LOCK:
         FIND FIRST tt-loan WHERE
                    tt-Loan.ContCode = b-loan.cont-code
         NO-ERROR.
         IF NOT AVAIL tt-loan THEN DO:
            CREATE tt-Loan.
            ASSIGN
               tt-Loan.ContCode = b-loan.cont-code
               tt-Loan.DocRef   = b-loan.doc-ref
               .
         END.
      END.
      
      FOR EACH b-loan WHERE
               b-loan.contract = iContract
           AND b-loan.cont-code BEGINS (ENTRY(1, iContCode, " ") + " ")
           AND b-loan.open-date <= iDate
      NO-LOCK:
         FIND FIRST tt-loan WHERE
                    tt-Loan.ContCode = b-loan.cont-code
         NO-ERROR.
         IF NOT AVAIL tt-loan THEN DO:
            CREATE tt-Loan.
            ASSIGN
               tt-Loan.ContCode = b-loan.cont-code
               tt-Loan.DocRef   = b-loan.doc-ref
               .
         END.
      END.
   END.

   FOR EACH tt-Loan:
      FOR EACH b-term-obl WHERE
         b-term-obl.contract  = iContract AND
         b-term-obl.cont-code = tt-Loan.ContCode AND
         b-term-obl.idnt      = 5         AND
         ( NOT (b-term-obl.sop-date <> ? AND b-term-obl.sop-date <= iDate) )
      NO-LOCK:

         ASSIGN
            /* значение ДР КачествоОбесп */
            mDRGQ = Get_QualityGar("comm-rate",
                                   iContract + "," + tt-Loan.ContCode + ","
                                   + STRING(b-term-obl.idnt) + ","
                                   + STRING(b-term-obl.end-date) + ","
                                   + STRING(b-term-obl.nn),
                                   iDate)

            /* значение ДР "ДатаПост */
            mDRInDate = GetXAttrValue("term-obl",
                                      iContract + "," + tt-Loan.ContCode + ","
                                      + STRING(b-term-obl.idnt) + ","
                                      + STRING(b-term-obl.end-date) + ","
                                      + STRING(b-term-obl.nn),
                                      "ДатаПост").

         IF    (    mDRInDate       NE ?
                AND mDRInDate       NE "?"
                AND mDRInDate       NE ""
                AND DATE(mDRInDate) GT iDate)
            OR mDRGQ = "?"
            OR mDRGQ = ?
            OR mDRGQ = ""
         THEN
            NEXT.

         /* учитывать категорию качества: если да, определяем индекс КК, если нет - индекс = 100 */
         IF iFlKK THEN
         DO:
            /* индекс качества обеспечения по классификатору "КачествоОбесп"*/
            mGQIndex  = DEC(GetCode("КачествоОбесп", mDRGQ )).

            IF mGQIndex < 0 OR mGQIndex > 100 THEN DO:
               IF mIfPutPtot THEN
               DO:
                  OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
                  PUT STREAM out_s UNFORMATTED
                  "Ошибка      Договор: " tt-Loan.DocRef FORMAT "X(22)"
                  ".  Некорректное значение индекса качества обеспечения. Значение индекса качества обеспечения принимается равным нулю."
                  SKIP.
                  OUTPUT STREAM out_s CLOSE.
               END.
               mGQIndex = 0.
            END.
         END.
         ELSE
            mGQIndex = 100.

         IF iFlGQIndex THEN
            /* mDecrRate - коэфф.снижения стоимости обеспечения (выполняется поиск
               коэффициента, установленного по объекту обеспечения на дату iDate)
            */
            mDecrRate = GET_COMM("Обесп",
                                 ?,
                                 b-term-obl.currency,
                                 iContract + "," + tt-Loan.ContCode + ","
                                 + STRING(b-term-obl.idnt) + ","
                                 + STRING(b-term-obl.end-date) + ","
                                 + STRING(b-term-obl.nn),
                                 0.00,
                                 0,
                                 iDate).
         ELSE
            mDecrRate = 100.

         IF mDecrRate = ? THEN mDecrRate = 100.
         IF mGQIndex  = ? THEN mGQIndex  = 0.

         ASSIGN
            /* стоимость объекта обеспечения */
            mGObjCost = LnPledge(iContract, tt-Loan.ContCode, b-term-obl.idnt,
                                 b-term-obl.end-date, b-term-obl.nn,
                                 iDate, iDateRate,iCurrency)
            /* сумма обеспечения по объекту */
            mGOSumm  = mGObjCost * mGQIndex / 100 * mDecrRate / 100
            mGOSumm  = CurrRound ( mGOSumm, iCurrency )
            mTotSumm = mTotSumm + mGOSumm
         .
         IF mIfPutPtot
            AND NOT(mIfPutNotNull
                    AND NUM-ENTRIES(tt-Loan.DocRef, " ") = 2
                    AND mGOSumm = 0) THEN
         DO:
             OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
             PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " tt-Loan.DocRef FORMAT "X(22)"
             ".  [Стоим. обесп. дог.] = [Стоим. объекта обесп.] * [Индекс качества] * [Коэф. остаточной стоим.]"
             SKIP
             "Информация  Договор: " tt-Loan.DocRef FORMAT "X(22)"
             "."
             mGOSumm   FORMAT "->>>>,>>>,>>>,>>9.99"
             " = "
             mGObjCost FORMAT "->>>>,>>>,>>>,>>9.99"
             " * "
             mGQIndex  FORMAT "->>>>,>>>,>>>,>>9.99"
             " % * "
             mDecrRate FORMAT "->>>>,>>>,>>>,>>9.99"
             SKIP.
             OUTPUT STREAM out_s CLOSE.
         END.
      END. /*FOR EACH*/

      IF mIfPutPtot
         AND NOT(mIfPutNotNull
             AND NUM-ENTRIES(tt-Loan.DocRef, " ") = 2
             AND mTotSumm = 0) THEN
      DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " tt-Loan.DocRef FORMAT "X(22)"
         ".  Стоимость обеспечения по договору в валюте "
         iCurrency FORMAT "x(3)"
         ": "
         mTotSumm  FORMAT "->>>>,>>>,>>>,>>9.99999"
         SKIP.
         OUTPUT STREAM out_s CLOSE.
      END.

   END. /* LOAN */

   RETURN mTotSumm.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnCollateralValueAll
  Name       : Сумма обеспечения по ссуде
  Purpose    : Вычисляет общую сумму обеспечения по указанному договору с
               учетом индекса качества обеспечения и коэффициента снижения
               стоимости обеспечения.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iDateRate   - дата пересчета курса
               iCurrency   - код валюты
               iTypeCalc   - "all" - по охват. договору + течениям
                             "one" - по одному конкретному договору
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnCollateralValueAll RETURNS DECIMAL (INPUT iContract AS CHAR,
                                               INPUT iContCode AS CHAR,
                                               INPUT iDate     AS DATE,
                                               INPUT iDateRate AS DATE,
                                               INPUT iCurrency AS CHAR,
                                               INPUT iTypeCalc AS CHAR).
   RETURN LnCollateralValueAllEx(iContract,
                                 iContCode,
                                 iDate,
                                 iDateRate,
                                 iCurrency,
                                 iTypeCalc,
                                 YES,
                                 YES).
END FUNCTION.

/*----------------------------------------------------------------------------
  Procedure  : LnCollateralValueEx
  Purpose    : Вычисляет часть суммы обеспечения для отнесения к основному долгу
               и к условным обязательствам.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iDateRate   - дата пересчета курса
               iCurrency   - код валюты
               oAmtLoan    - часть суммы обеспечения по основному долгу
               oAmtAcct    - часть суммы обеспечения по условным обязательствам
  Notes      :
  ----------------------------------------------------------------------------*/
PROCEDURE LnCollateralValueEx.

    DEF INPUT  PARAM iContract AS CHAR NO-UNDO.
    DEF INPUT  PARAM iContCode AS CHAR NO-UNDO.
    DEF INPUT  PARAM iDate     AS DATE NO-UNDO.
    DEF INPUT  PARAM iDateRate AS DATE NO-UNDO.
    DEF INPUT  PARAM iCurrency AS CHAR NO-UNDO.
    DEF OUTPUT PARAM oAmtLoan  AS DEC  NO-UNDO.
    DEF OUTPUT PARAM oAmtAcct  AS DEC  NO-UNDO.

    DEF VAR vObespSumm   AS DEC  NO-UNDO.
    DEF VAR vAcctSumm    AS DEC  NO-UNDO.
    DEF VAR mLnkContCode AS CHAR NO-UNDO.
    DEF VAR vODSumm      AS DEC  NO-UNDO.
    DEF VAR i            AS INT64  NO-UNDO.
    DEF VAR vCalcMeth    AS CHAR NO-UNDO. /* ДР СпособРасч */
    DEF VAR vDoc-ref     AS CHAR NO-UNDO.
    DEF VAR vRoleSchVn   AS CHAR   NO-UNDO. 

    DEF BUFFER loan FOR loan.

    mb:
    DO ON ERROR UNDO, LEAVE:
 
       FIND FIRST loan WHERE
                 loan.contract  EQ iContract
             AND loan.cont-code EQ iContCode
       NO-LOCK NO-ERROR. 
       IF AVAIL loan THEN
          vDoc-ref = loan.doc-ref.
       vCalcMeth = GetXattrValueEx("loan",
                                   iContract + "," + iContCode,
                                   "СпособРасч",
                                   "").
       IF NOT {assigned vCalcMeth} THEN
       DO:
          IF NOT AVAIL loan THEN
             LEAVE mb.
          vCalcMeth = GetXAttrInit(loan.class-code,
                                   "СпособРасч").
          IF NOT {assigned vCalcMeth} THEN
             vCalcMeth = FGetSetting("РасчОбесп", "СпособРасч", ?). 
       END.

       /* Определим значение настроечного параметра РасчОбесп/РольСчВн */
       ASSIGN 
          vRoleSchVn    = FGetSetting("РасчОбесп", "РольСчВн", "").

       IF vCalcMeth EQ "Пропорционально" OR
          vCalcMeth EQ "По превышению" THEN
       DO:
          ASSIGN
             vObespSumm = LnCollateralValueAll(iContract,iContCode,iDate,iDateRate,iCurrency,"all")
             oAmtLoan   = vObespSumm
          .

          /* Проверяем принадлежность к ПОС */
          mLnkContCode = LnInBagOnDate(iContract,
                                       ENTRY(1, iContCode, " "),
                                       iDate).

          IF mLnkContCode <> ? THEN
          DO:
             /* Если НП ╓РезервПОС· = ╓Да·, то для портфельной ссуды обеспечение не
                учитывается вовсе при любом способе распределения обеспечения (т.е. сумма
                обеспечения для основного долга и для внебаланса равна 0). */
             IF FGetSetting("РезервПОС",?,?) EQ "Да" THEN
             DO:
                ASSIGN
                   oAmtLoan = 0
                   oAmtAcct = 0
                .
                LEAVE mb.
             END.
          END.

          /* По ролям счетов из НП - ищем до первого найденого счета - счет */
          sb:
          DO i = 1 TO NUM-ENTRIES(vRoleSchVn):
             FIND LAST loan-acct WHERE loan-acct.contract  EQ iContract
                                   AND loan-acct.cont-code EQ ENTRY(1, iContCode, " ")
                                   AND loan-acct.acct-type EQ ENTRY(i, vRoleSchVn)
                                   AND loan-acct.since     LE iDate
             NO-LOCK NO-ERROR.
             IF AVAIL loan-acct THEN
                LEAVE sb.
          END. /* sb */

          /* Если счета так и не нашли, то вся сумма относится к основному долгу */
          IF NOT AVAIL loan-acct THEN
             LEAVE mb.

          /* Вычисляем остаток на найденном счете, если он равен 0, то
          ** вся сумма относится к основному долгу */
          RUN acct-pos IN h_base (loan-acct.acct,loan-acct.currency,iDate,iDate,gop-status).
          vAcctSumm = IF loan-acct.currency EQ ""
                         THEN ABS(sh-bal)
                         ELSE ABS(sh-val) * findratesimple ('Учетный',
                                                            loan-acct.currency,
                                                            iDate).
          IF vAcctSumm EQ 0 THEN
             LEAVE mb.

          /* Вычисляем сумму основного долга по ссуде, если он равен 0, то
          ** вся сумма относится к условным обязательствам */
          vODSumm = LnPrincipal (iContract,
                                 ENTRY(1, iContCode, " "),
                                 iDate,
                                 "").

          IF vODSumm EQ 0 THEN
          DO:
             ASSIGN
                oAmtLoan = 0
                oAmtAcct = vObespSumm
             .
             LEAVE mb.
          END.

          IF vCalcMeth EQ "Пропорционально" THEN
          DO:
             /* Если прошли все проверки и значеие НП - "Пропорционально", значит делим сумму */
             /* Если в знаменателе ноль или отриц.число, то эта часть равна нулю */
             IF vODSumm + vAcctSumm LE 0 THEN
                oAmtLoan = 0.
             ELSE
                oAmtLoan = vObespSumm * vODSumm / ( vODSumm + vAcctSumm ).

             oAmtAcct = vObespSumm - oAmtLoan.
          END.
          ELSE /* НП - "По превышению" */
             IF vObespSumm LE vODSumm THEN
                ASSIGN
                   oAmtLoan = vObespSumm
                   oAmtAcct = 0
                .
             ELSE
                ASSIGN
                   oAmtLoan = vODSumm
                   oAmtAcct = vObespSumm - vODSumm
                   oAmtAcct = IF oAmtAcct GT vAcctSumm THEN vAcctSumm
                                                       ELSE oAmtAcct
                .
       END.
       ELSE
          ASSIGN
             vObespSumm = LnCollateralValueAll(iContract,iContCode,iDate,iDateRate,iCurrency,"one")
             oAmtLoan   = vObespSumm
          .
       
       IF mIfPutPtot THEN
       DO:
          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " vDoc-ref FORMAT "X(22)"
             ". СпособРасч = " vCalcMeth SKIP.
          if vCalcMeth EQ "Пропорционально" THEN
             PUT STREAM out_s UNFORMATTED
                 "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                 ". [Часть суммы обесп.по ОД] = ([Общ.сумма обесп.] * [Сумма ОД]) / ([Сумма ОД] + [Ост.на счетах с ролями с НП РольСчВн]) "
                 oAmtLoan FORMAT "->>>>,>>>,>>>,>>9.99"
                 " = ("
                 vObespSumm FORMAT "->>>>,>>>,>>>,>>9.99"
                 " * "
                 vODSumm FORMAT "->>>>,>>>,>>>,>>9.99"
                 ") / ("
                 vODSumm FORMAT "->>>>,>>>,>>>,>>9.99"
                 " + "
                 vAcctSumm FORMAT "->>>>,>>>,>>>,>>9.99"
                 ")" SKIP
                 "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                 ". [Часть суммы обесп.по УО] = [Общ.сумма обесп.] - [Часть суммы обесп.по ОД] "
                 oAmtAcct FORMAT "->>>>,>>>,>>>,>>9.99"
                 " = "
                 vObespSumm FORMAT "->>>>,>>>,>>>,>>9.99"
                 " - "
                 oAmtLoan FORMAT "->>>>,>>>,>>>,>>9.99"
                 SKIP.
          ELSE if vCalcMeth EQ "По превышению" then
             PUT STREAM out_s UNFORMATTED
                 "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                 ". [Часть суммы обесп.по ОД] = MIN([Общ.сумма обесп.],[Сумма ОД]) "
                 oAmtLoan FORMAT "->>>>,>>>,>>>,>>9.99"
                 " = MIN("
                 vObespSumm FORMAT "->>>>,>>>,>>>,>>9.99"
                 ","
                 vODSumm FORMAT "->>>>,>>>,>>>,>>9.99"
                 ")" SKIP
                 "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                 ". [Часть суммы обесп.по УО] = [Общ.сумма обесп.] - [Часть суммы обесп.по ОД] "
                 oAmtAcct FORMAT "->>>>,>>>,>>>,>>9.99"
                 " = "
                 vObespSumm FORMAT "->>>>,>>>,>>>,>>9.99"
                 " - "
                 oAmtLoan FORMAT "->>>>,>>>,>>>,>>9.99"
                 SKIP.
          ELSE
             PUT STREAM out_s UNFORMATTED
                 "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                 ". [Часть суммы обесп.по ОД] = [Общ.сумма обесп.] "
                 oAmtLoan FORMAT "->>>>,>>>,>>>,>>9.99"
                 " = "
                 vObespSumm FORMAT "->>>>,>>>,>>>,>>9.99" SKIP
                 "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                 ". [Часть суммы обесп.по УО] = 0 "
                 oAmtAcct FORMAT "->>>>,>>>,>>>,>>9.99"
                 " = "
                 "0" FORMAT "->>>>,>>>,>>>,>>9.99"
                 SKIP.
          OUTPUT STREAM out_s CLOSE.
       END.
    END. /* mb */

END PROCEDURE.

/*---------------------------------------------------------------------------
  Function   : LnCollateralValue
  Name       : Сумма обеспечения по ссуде
  Purpose    : Вычисляет часть суммы обеспечения по основному долгу по указанному
               договору с учетом индекса качества обеспечения и коэффициента снижения
               стоимости обеспечения.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnCollateralValue RETURNS DECIMAL (INPUT iContract AS CHAR,
                                            INPUT iContCode AS CHAR,
                                            INPUT iDate     AS DATE,
                                            INPUT iCurrency AS CHAR).
   DEF VAR oLoanObesp AS DEC  NO-UNDO.
   DEF VAR vAmtLoan   AS DEC  NO-UNDO.
   DEF VAR vAmtAcct   AS DEC  NO-UNDO.
   DEF VAR vTrObesp   AS DEC  NO-UNDO.
   DEF VAR vCorrFlg   AS LOG  NO-UNDO.
   DEF VAR vCalcMeth  AS CHAR NO-UNDO. /* ДР СпособРасч */
   DEF VAR vDoc-ref   AS CHAR NO-UNDO.
   DEF BUFFER b-loan  FOR loan.
   DEF BUFFER z-loan  FOR loan.

   MAIN:
   DO ON ERROR UNDO, LEAVE:
      
      FIND FIRST b-loan WHERE
                 b-loan.contract  EQ iContract
             AND b-loan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
      IF AVAIL b-loan THEN
         vDoc-ref = b-loan.doc-ref.
         /* Вычисляем сумму обеспечения ОД (основного долга) и УО (условных обязательств) */
      RUN LnCollateralValueEx (iContract,
                               iContCode,
                               iDate,
                               ?,
                               iCurrency,
                               OUTPUT vAmtLoan,
                               OUTPUT vAmtAcct).
         /* Обеспечение по ОД */
      oLoanObesp = vAmtLoan.
      vCalcMeth = GetXattrValueEx("loan",
                                  iContract + "," + iContCode,
                                  "СпособРасч",
                                  "").
      IF NOT {assigned vCalcMeth} THEN
      DO:
         IF NOT AVAIL b-loan THEN
            LEAVE MAIN.
         vCalcMeth = GetXAttrInit(b-loan.class-code,
                                  "СпособРасч").
         IF NOT {assigned vCalcMeth} THEN
            vCalcMeth = FGetSetting("РасчОбесп", "СпособРасч", ?).
      END.
         /* Проверяем необходимость корректировки суммы обеспечения по ОД */
         /* Если обеспечение по ОД есть вообще (иначе нечего и корректировать),
         ** и mNpRas = НП "РасчОбесп" -> "СпособРасч" - Способ расчета обеспечения =
         ** "Пропорционально" или "По превышению" */
      IF     (vAmtLoan NE 0)
         AND (vCalcMeth   EQ "Пропорционально"
           OR vCalcMeth   EQ "По превышению") THEN
      DO:
         IF AVAIL b-loan THEN
         DO:
            IF b-loan.cont-type EQ "Течение" THEN
               vCorrFlg = TRUE.     /* Взводим флаг корректировки */
            ELSE
            DO:
                  /* Определяем, не является ли данный договор траншем:
                  ** Пытаемся найти охватывающий договор, т.к. по cont-code транш
                  ** определять нельзя - это не работает в многофилиальной базе */
               FIND FIRST z-loan WHERE
                          z-loan.contract   EQ b-loan.contract
                  AND     z-loan.filial-id  EQ b-loan.filial-id
                  AND     z-loan.doc-ref    EQ ENTRY(1, b-loan.doc-ref, " ")
                  AND     RECID(z-loan)     NE RECID(b-loan)
               NO-LOCK NO-ERROR.
               IF AVAIL z-loan THEN
                  vCorrFlg = TRUE.     /* Взводим флаг корректировки */
            END.
         END.
      END.
         /* Если договор имеет тип "Течение" или является траншем - требуется
         ** корректировка полученной суммы обеспечения по договору */
      IF vCorrFlg THEN
      DO:
            /* Вычисляем всю сумму обеспечения данного соглашения/транша */
         vTrObesp = LnCollateralValueAll(iContract,
                                         iContCode,
                                         iDate,
                                         ?,
                                         iCurrency,
                                         "one").
            /* Вычислем сумму обеспечения, относящуюся к данному течению/траншу
            ** с учетом доли, относящейся к ОД */
         oLoanObesp = IF vAmtLoan + vAmtAcct NE 0
                         THEN vTrObesp * vAmtLoan / (vAmtLoan + vAmtAcct)
                         ELSE 0.
      END.
   END.
   IF mIfPutPtot THEN
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " vDoc-ref FORMAT "X(22)".
      IF vCorrFlg THEN
      DO:
         PUT STREAM out_s UNFORMATTED
             ". [Стоим. обесп. согл.] = ".
         PUT STREAM out_s UNFORMATTED
             IF (vAmtLoan + vAmtAcct) EQ 0 THEN "0.00"
             ELSE "[Стоим. обесп. согл./транша] * [Часть суммы обесп.по ОД] / ([Часть суммы обесп.по ОД] + [Часть суммы обесп.по УО]) ".
         PUT STREAM out_s UNFORMATTED
             oLoanObesp FORMAT "->>>>,>>>,>>>,>>9.99"
             " = ".
         IF vAmtLoan + vAmtAcct EQ 0 THEN
            PUT STREAM out_s UNFORMATTED "0.00" SKIP.
         ELSE
            PUT STREAM out_s UNFORMATTED
               vTrObesp FORMAT "->>>>,>>>,>>>,>>9.99"
               " * "
               vAmtLoan FORMAT "->>>>,>>>,>>>,>>9.99"
                " / ("
               vAmtLoan FORMAT "->>>>,>>>,>>>,>>9.99"
               " + "
               vAmtAcct FORMAT "->>>>,>>>,>>>,>>9.99"
               ")"
            SKIP.
      END.
      ELSE
         PUT STREAM out_s UNFORMATTED
             ". [Стоим. обесп. согл.] = [Часть суммы обесп.по ОД] "
             oLoanObesp FORMAT "->>>>,>>>,>>>,>>9.99"
             " = "
             vAmtLoan FORMAT "->>>>,>>>,>>>,>>9.99"
         SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.
   
   RETURN oLoanObesp.
END FUNCTION.

/*----------------------------------------------------------------------------
  Procedure  : ClcAcctDeriv
  Purpose    : Вычисление сумм процентов по счету
  Parameters : iAcct     - счет
               iBegDate  - дата
               loan      - буффер loan'a
               oProc1    - Процент первой записи
               oProc2    - Процент второй записи
               oOk       - Флаг успешности работы процедуры
  Notes      :
  ----------------------------------------------------------------------------*/
PROCEDURE ClcAcctDeriv.

    DEF INPUT  PARAM  iAcct     AS CHAR NO-UNDO.
    DEF INPUT  PARAM  iBegDate  AS DATE NO-UNDO.
    DEF PARAM  BUFFER loan      FOR loan.
    DEF OUTPUT PARAM  oProc1    AS DEC  NO-UNDO.
    DEF OUTPUT PARAM  oProc2    AS DEC  NO-UNDO.
    DEF OUTPUT PARAM  oParamFI  AS CHAR NO-UNDO.
    DEF OUTPUT PARAM  oRisk     AS CHAR NO-UNDO.
    DEF OUTPUT PARAM  oOk       AS LOG  NO-UNDO.

    DEF VAR mShBal      AS DEC   NO-UNDO.
    DEF VAR mAcctObesp  AS DEC   NO-UNDO.
    DEF VAR mLoanObesp  AS DEC   NO-UNDO.
    DEF VAR vFlDosrZakr AS CHAR  NO-UNDO.
    DEF VAR vSrok       AS CHAR  NO-UNDO.
    DEF VAR vFlProl     AS LOG   NO-UNDO.
    DEF VAR vEndDate    AS DATE  NO-UNDO.
    DEF VAR vCurDt      AS DATE  NO-UNDO.
    DEF VAR vCntDays    AS INT64 NO-UNDO.

    DEF BUFFER xacct     FOR acct.
    DEF BUFFER loan-acct FOR loan-acct.

    mb:
    DO ON ERROR UNDO, LEAVE:

       FIND code WHERE code.class EQ "ПарамФИ"
                   AND ENTRY(1,CODE.code,"_") EQ SUBSTRING(iAcct,1,5) NO-LOCK NO-ERROR.

       /* Возвращает Да, если нашлось больше одной записи */
       IF NOT AMBIGUOUS code THEN
       DO:
          IF NOT AVAIL code THEN
             LEAVE mb.
       END.
       ELSE
       DO:
          /* По классификатору СрокБал ищем по счету с ролью Кредит */
          FIND LAST loan-acct WHERE loan-acct.contract  EQ loan.contract
                                AND loan-acct.cont-code EQ loan.cont-code
                                AND loan-acct.acct-type EQ "Кредит"
          NO-LOCK NO-ERROR.
          IF NOT AVAIL loan-acct THEN
             LEAVE mb.

          /* Расчитываем код ФИ */
          /* Получаем параметр ДосрЗакр */
          vFlDosrZakr = GetXattrValueEx("loan",
                                        loan.contract + "," + loan.cont-code,
                                        "ДосрЗакр",
                                        "").
          /* Если с правом досрочного закрытия */
          IF vFlDosrZakr EQ 'Да' THEN
             vSrok = "с правом досрочного закрытия".
          /* Иначе вычисляем является ли договор долгосрочным или краткосрочным */
          ELSE DO:
             /* Ичитывать пролонгацию при расчете срока или нет */
             vFlProl = (IF FGetSetting("РасчОбесп","Срок","") EQ 'с учетом' THEN
                           TRUE
                        ELSE FALSE).
             /* Вычисляем дату окончания договора */
             FIND LAST term-obl WHERE     term-obl.contract  = loan.contract 
                                      AND term-obl.cont-code = loan.cont-code
                                      AND term-obl.idnt      = 3 
                                      NO-LOCK NO-ERROR.
             IF NOT AVAIL term-obl THEN
                LEAVE mb.
             /* С учетом пролонгации */
             IF vFlProl THEN
                vEndDate = term-obl.end-date.
             /* Без учета пролонгации */
             ELSE DO:
                vCurDt = term-obl.end-date.
                DO WHILE TRUE:
                   FIND FIRST pro-obl WHERE     pro-obl.contract   = term-obl.contract
                                            AND pro-obl.cont-code  = term-obl.cont-code
                                            AND pro-obl.idnt       = 3
                                            AND pro-obl.n-end-date = vCurDt 
                                            NO-LOCK NO-ERROR.
                   IF AVAIL pro-obl THEN
                      vCurDt = pro-obl.end-date.
                   ELSE 
                      LEAVE.
                END. 
                vEndDate = vCurDt.
             END.
             /* Количество дней кредита */
             vCntDays = vEndDate - loan.open-date.
             /* долгосрочный (больше года) или краткосрочный */
             IF GoMonth(loan.open-date,12) LT vEndDate THEN 
                vSrok = "долгосрочные".
             ELSE
                vSrok = "краткосрочные".
          END.
          FOR EACH code WHERE 
                   code.class   EQ "ПарамФИ"
               AND code.code    BEGINS SUBSTRING(iAcct,1,5) + '_'
               AND code.misc[1] EQ vSrok 
          NO-LOCK:
             /* Как только нашли, выходим - т.к. это уже то что надо */
             LEAVE.
          END.
          IF NOT AVAIL code THEN
             LEAVE mb.
       END.

       /* На этом этапе у нас есть одна запись из классификатора ПарамФИ, с ним дальше и работаем */
       IF NUM-ENTRIES(code.code,"_") NE 2 THEN
          LEAVE mb.
       ELSE
          ASSIGN
             oParamFI = ENTRY(2,code.code,"_")
             oRisk    = code.misc[2].

       FIND FIRST xacct WHERE xacct.acct EQ iAcct NO-LOCK NO-ERROR.
       IF NOT AVAIL xacct THEN
          LEAVE mb.

       RUN acct-pos IN h_base (xacct.acct,xacct.currency,iBegDate,iBegDate,gop-status).
       mShBal = ABS(sh-bal).

       /* Остаток на счете 0, то oProc1 = 100, oProc2 = 0 соответственно */
       IF mShBal EQ 0 THEN
       DO:
          ASSIGN
             oProc1 = 100
             oOk    = YES.
          LEAVE mb.
       END.
       ELSE
       DO:
          RUN LnCollateralValueEx (loan.contract,
                                   loan.cont-code,
                                   iBegDate,
                                   ?,
                                   "",
                                   OUTPUT mLoanObesp,
                                   OUTPUT mAcctObesp).
          IF mShBal < mAcctObesp THEN
             mAcctObesp = mShBal.

          ASSIGN
             oProc1 = mAcctObesp * 100 / mShBal
             oProc2 = 100 - oProc1
             oOk    = YES.
       END.
    END. /* mb */

END PROCEDURE.

/*---------------------------------------------------------------------------
  Function   : LnUncoveredLoan
  Name       : Необеспеченная часть ссуды
  Purpose    : вычисляет необеспеченную часть ссуды,относящуюся к отдельному
               договору. Не работает с договорами типа "Течение".

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnUncoveredLoan RETURNS DECIMAL (INPUT iContract AS CHAR,
                                          INPUT iContCode AS CHAR,
                                          INPUT iDate     AS DATE,
                                          INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan FOR loan.

   DEF VAR mDebtSumm AS DEC NO-UNDO. /* сумма основного долга */
   DEF VAR mGuarSumm AS DEC NO-UNDO. /* сумма обеспечения */
   DEF VAR mResult   AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Расчет необеспеченной суммы кредита за "
      STRING(iDate, "99/99/9999") + "."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   IF b-loan.cont-type = "Течение" THEN  RETURN 0.00.

   ASSIGN
      /* основной долг по ссуде */
      mDebtSumm = LnPrincipal(iContract,iContCode,iDate,iCurrency)
      /* сумма обеспечения по ссуде */
      mGuarSumm = LnCollateralValue(iContract,iContCode,iDate,iCurrency)
      mResult   = mDebtSumm - mGuarSumm.


   IF mIfPutPtot THEN
   DO:
       IF mResult < 0.00 THEN
       DO:
          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
             ".  Скорректированная стоимость обеспечения превышает общую задолженность."
             SKIP.
          OUTPUT STREAM out_s CLOSE.
       END.
       ELSE IF NOT(mIfPutNotNull
                   AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
                   AND mDebtSumm = 0
                   AND mGuarSumm = 0) THEN DO:

          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
              "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
              ".  [Необесп. сумма кредита] = [Общая задолж.] - [Стоим. обесп. дог.]"
              SKIP.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
             "."
             mResult FORMAT "->>>>,>>>,>>>,>>9.99"
             " = "
             mDebtSumm FORMAT "->>>>,>>>,>>>,>>9.99"
             " - "
             mGuarSumm FORMAT "->>>>,>>>,>>>,>>9.99"
             SKIP.
          OUTPUT STREAM out_s CLOSE.
       END.
   END.

   RETURN (IF mResult < 0.00 THEN 0 ELSE mResult).

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnCollateralValueAgr
  Name       : Часть обеспечения соглашения, относящаяся к траншу
  Purpose    : вычисляет часть суммы обеспечения, зарегистрированного по
               соглашению о траншевой кредитной линии, относящуюся к данному
               траншу.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnCollateralValueAgr RETURNS DECIMAL (INPUT iContract AS CHAR,
                                               INPUT iContCode AS CHAR,
                                               INPUT iDate     AS DATE,
                                               INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan       FOR loan.
   DEF BUFFER b-upper-loan FOR loan.

   DEF VAR mUncovSumm     AS DEC NO-UNDO. /* необеспеченная часть транша по текущему договору */
   DEF VAR mGuarSumm      AS DEC NO-UNDO. /* сумма обеспечения по соглашению */
   DEF VAR mUncovTrSumm   AS DEC NO-UNDO. /* необеспеченная часть ссуды по траншу */
   DEF VAR mTotUncovSumm  AS DEC NO-UNDO. /* необеспеченная часть ссуды по соглашению */
   DEF VAR mResult        AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   DEFINE VARIABLE vDoc-ref AS CHAR NO-UNDO.
   vDoc-ref = b-loan.doc-ref.

   IF b-loan.cont-type = "Течение" OR
      NUM-ENTRIES(b-loan.cont-code, " ") <> 2
   THEN  RETURN 0.00.

   /* ищем вышестоящий договор */
   FIND FIRST b-upper-loan
      WHERE   b-upper-loan.cont-type = "Течение" AND
              b-upper-loan.contract  = iContract AND
              b-upper-loan.cont-code = ENTRY(1,iContCode, " ")
   NO-LOCK NO-ERROR.

   IF NOT AVAIL b-upper-loan THEN  RETURN 0.00.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(vDoc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " vDoc-ref FORMAT "X(22)"
      ".  Расчет части стоимости обеспечения соглашения, относящейся к данному течению (траншу) за "
      STRING(iDate, "99/99/9999") + "."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   /* сумма обеспечения по соглашению, вычисленная по вышестоящему договору */
   mGuarSumm = LnCollateralValue(b-upper-loan.contract,
                                 b-upper-loan.cont-code,iDate,iCurrency).
   IF mGuarSumm = 0 THEN RETURN 0.00.

   /* необеспеченная часть транша по текущему договору */
   mUncovSumm = LnUncoveredLoan(iContract,iContCode,iDate,iCurrency).
   IF mUncovSumm = 0 THEN RETURN 0.00.

   /* для всех течений вышестоящего договора, кроме тех, которые открыты
      позже iDate или закрыты ранее iDate
   */
   FOR EACH b-loan WHERE b-loan.contract   = b-upper-loan.contract  AND
                         b-loan.cont-code  BEGINS b-upper-loan.cont-code AND
                         NUM-ENTRIES(b-loan.cont-code, " ") = 2 AND
                         ENTRY(1, b-loan.cont-code, " ") = b-upper-loan.cont-code AND
                         b-loan.open-date <= iDate
                 NO-LOCK:

      IF b-loan.close-date <> ? AND b-loan.close-date <= iDate THEN NEXT.

      ASSIGN
         /* необеспеченная часть ссуды по очередному течению */
         mUncovTrSumm = LnUncoveredLoan(b-loan.contract,
                                        b-loan.cont-code,iDate,iCurrency)
         /* необеспеченная часть ссуды по соглашению */
         mTotUncovSumm = mTotUncovSumm + mUncovTrSumm.
   END.
   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(vDoc-ref, " ") = 2
              AND mTotUncovSumm = 0) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " vDoc-ref FORMAT "X(22)"
      ".  Необеспеченная сумма кредита по всем течениям договора "
      b-upper-loan.cont-code FORMAT "x(22)"
      " в валюте "
      iCurrency FORMAT "x(3)"
      ": "
      mTotUncovSumm FORMAT "->>>>,>>>,>>>,>>9.99"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   mResult = mGuarSumm * mUncovSumm / mTotUncovSumm.

   IF  mIfPutPtot
      AND mTotUncovSumm <> 0.00 THEN
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " vDoc-ref FORMAT "X(22)"
         ".  [Часть стоим. обесп. согл.] = [Стоим. обесп. согл.] * [Необесп. сумма кредита] / [Общая необесп. сумма кредита]"
         mResult FORMAT "->>>>,>>>,>>>,>>9.99"
         " = "
         mGuarSumm FORMAT "->>>>,>>>,>>>,>>9.99"
         " * "
         mUncovSumm FORMAT "->>>>,>>>,>>>,>>9.99"
         " / "
         mTotUncovSumm FORMAT "->>>>,>>>,>>>,>>9.99"
         SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(vDoc-ref, " ") = 2
              AND mResult = 0) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " vDoc-ref FORMAT "X(22)"
      ".  Стоимость обеспечения соглашения, относящаяся к данному течению в валюте "
      iCurrency FORMAT "x(3)"
      ": "
      CurrRound ( mResult, iCurrency ) FORMAT "->>>>,>>>,>>>,>>9.99"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   RETURN  CurrRound ( mResult, iCurrency ).

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrv
  Name       : Формируемый резерв
  Purpose    : возвращает величину формируемого резерва по договору. Если в
               договоре не ведется учет резерва, то функция возвратит ноль.
               По договорам с течениями формируемый резерв будет определен
               для всех траншей договора.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrv RETURNS DECIMAL (INPUT iContract AS CHAR,
                                     INPUT iContCode AS CHAR,
                                     INPUT iDate     AS DATE,
                                     INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan    FOR loan.
   DEF BUFFER loan      FOR loan.
   DEF BUFFER loan-cond FOR loan-cond.

   DEF VAR mSyndLoan  AS LOG NO-UNDO.           /* признак синдицированной ссуды */
   DEF VAR mFormRsrv  AS DEC INIT 0 NO-UNDO.    /* формируемый резерв по соглашению */
   DEF VAR mRsrvRate  AS DEC INIT 0 NO-UNDO.    /* коэффициент резервирования */
   DEF VAR mBasicDebt AS DEC INIT 0 NO-UNDO.    /* основной долг по соглашению */
   DEF VAR mPartAmt   AS DEC INIT 0 NO-UNDO.    /* сумма участия по соглашению */
   DEF VAR mGuarSummTr   AS DEC  NO-UNDO.       /* сумма обеспечения */
   DEF VAR mGuarSummLoan AS DEC  NO-UNDO.       /* сумма обеспечения по соглашению */
   DEF VAR mGuarSummPart AS DEC  NO-UNDO.       /* часть суммы обеспечения соглашения */
   DEF VAR mCalcRsrvBase AS DEC  NO-UNDO.       /* база расчета резерва */
   DEF VAR mResult       AS DEC  NO-UNDO.
   DEF VAR mFlNotRound   AS CHAR NO-UNDO.       /* флаг отмены округления при расчете резерва*/


   IF (FGetSetting("РезервПОС",?,"нет") = "да")
   THEN
      IF ({assignex LnInBagOnDate(iContract,iContCode,iDate)})
      THEN
         RETURN LnCalcRsrv(iContract,iContCode,iDate,iCurrency).

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).
   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
       AND NOT(mIfPutNotNull
               AND NUM-ENTRIES( b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Расчет общей величины Формируемого резерва за "
      STRING(iDate) + "."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.
   IF LnRsrvCheck(iContract, iContCode) = FALSE THEN RETURN 0.00.
   mFlNotRound = GetSysConf ("FlNotRound").
   IF mFlNotRound EQ "YES" THEN 
   DO:
      {i254.i &SetFormRsrv = "YES" &SetNotRound = "YES"}
   END.
   ELSE DO:
      {i254.i &SetFormRsrv = "YES"}
   END.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvTransh
  Name       : Формируемый резерв для траншей
  Purpose    : возвращает величину формируемого резерва по договору. Если в
               договоре не ведется учет резерва, то функция возвратит ноль.
               Для договоров-соглашений (тип Течение) формируемый резерв = 0.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvTransh RETURNS DECIMAL (INPUT iContract AS CHAR,
                                           INPUT iContCode AS CHAR,
                                           INPUT iDate     AS DATE,
                                           INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan    FOR loan.
   DEF BUFFER loan      FOR loan.
   DEF BUFFER loan-cond FOR loan-cond.

   DEF VAR mSyndLoan  AS LOG NO-UNDO.           /* признак синдицированной ссуды */
   DEF VAR mFormRsrv  AS DEC INIT 0 NO-UNDO.    /* формируемый резерв по соглашению */
   DEF VAR mRsrvRate  AS DEC INIT 0 NO-UNDO.    /* коэффициент резервирования */
   DEF VAR mBasicDebt AS DEC INIT 0 NO-UNDO.    /* основной долг по соглашению */
   DEF VAR mPartAmt   AS DEC INIT 0 NO-UNDO.    /* сумма участия по соглашению */
   DEF VAR mGuarSummTr   AS DEC NO-UNDO.        /* сумма обеспечения */
   DEF VAR mGuarSummLoan AS DEC NO-UNDO.        /* сумма обеспечения по соглашению */
   DEF VAR mGuarSummPart AS DEC NO-UNDO.        /* часть суммы обеспечения соглашения */
   DEF VAR mCalcRsrvBase AS DEC NO-UNDO.        /* база расчета резерва */
   DEF VAR mResult       AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).
   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Расчет общей величины Формируемого резерва за "
      STRING(iDate) + " (Режим: расчет по траншам)."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   IF b-loan.cont-type = "Течение" THEN
   DO:
      IF mIfPutPtot THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Договор имеет тип 'Течение'. Для договоров такого вида Формируемый резерв считается равным нулю."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      RETURN 0.00.
   END.

   {i254.i &SetFormRsrv = "YES" &SetNotRound = "YES"}

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvGoodDebt
  Name       : Формируемый резерв по срочной задолженности
  Purpose    : возвращает часть суммы формируемого резерва, относящуюся к
               срочной задолженности по договору.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvGoodDebt RETURNS DECIMAL (INPUT iContract AS CHAR,
                                             INPUT iContCode AS CHAR,
                                             INPUT iDate     AS DATE,
                                             INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan FOR loan.

   DEF VAR mFormRsrvSumm AS DEC NO-UNDO.
   DEF VAR mBasicDebt AS DEC INIT 0 NO-UNDO.    /* основной долг по соглашению */
   DEF VAR mFixedDebt AS DEC INIT 0 NO-UNDO.    /* срочная задолженность */
   DEF VAR mResult    AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).
   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Расчет величины формируемого резерва по срочной задолженности за "
      STRING(iDate) + "."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   /* сумма формируемого резерва */
   RUN SetSysConf IN h_base ("FlNotRound", "YES") .
   mFormRsrvSumm = LnFormRsrv(iContract,iContCode,iDate,iCurrency).    
   mFormRsrvSumm = CurrRound(mFormRsrvSumm,iCurrency).  
   RUN DeleteOldDataProtocol IN h_base ("FlNotRound").

   IF mFormRsrvSumm = 0.00 THEN  RETURN 0.00.

   ASSIGN
      /* сумма основного долга */
      mBasicDebt = LnPrincipal(iContract,iContCode,iDate,iCurrency)

      /* сумма срочной задолженности */
      mFixedDebt = LnGoodDebt(iContract,iContCode,iDate,iCurrency).

   IF mFixedDebt = mBasicDebt THEN
   DO:
      IF mIfPutPtot
         AND NOT(mIfPutNotNull
                 AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
                 AND mFixedDebt = 0) THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Нет просроченной задолженности. Формируемый резерв по срочной задолженности равен общему Формируемому резерву."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      RETURN mFormRsrvSumm.
   END.

   /* часть основного резерва, относящаяся к срочной задолженности */
   mResult = CurrRound ( mFormRsrvSumm * mFixedDebt / mBasicDebt, iCurrency ).

   IF mIfPutPtot
       AND NOT(mIfPutNotNull
               AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
               AND mResult = 0) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Существует просроченная задолженность. Формируемый резерв по срочной задолженности будет рассчитан пропорционально:"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  [Формируемый резерв по срочной задолже.] = [Общий формируемый резерв] * [Срочная задолж.] / [Общая задолж.]"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      "."
      mResult FORMAT "->>,>>>,>>>,>>>,>>9.99"
      " = "
      mFormRsrvSumm FORMAT "->>,>>>,>>>,>>>,>>9.99"
      " * "
      mFixedDebt FORMAT "->>,>>>,>>>,>>>,>>9.99"
      " / "
      mBasicDebt FORMAT "->>,>>>,>>>,>>>,>>9.99"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Формируемый резерв по срочной задолженности в валюте "
      iCurrency FORMAT "x(3)"
      ": "
      mResult FORMAT "->>,>>>,>>>,>>>,>>9.99"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.
END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvBadDebt
  Name       : Формируемый резерв по просроченной задолженности
  Purpose    : возвращает часть суммы формируемого резерва, относящуюся к
               просроченной задолженности по договору.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvBadDebt RETURNS DECIMAL (INPUT iContract AS CHAR,
                                            INPUT iContCode AS CHAR,
                                            INPUT iDate     AS DATE,
                                            INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan FOR loan.

   DEF VAR mFormRsrvSumm    AS DEC NO-UNDO. /* формируемый резерв */
   DEF VAR mFormRsrvSummFix AS DEC NO-UNDO. /* формируемый резерв по срочной задол.*/
   DEF VAR mBasicDebt       AS DEC INIT 0 NO-UNDO. /* основной долг по соглашению */
   DEF VAR mFixedDebt       AS DEC INIT 0 NO-UNDO. /* срочная задолженность */
   DEF VAR mResult          AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Расчет величины формируемого резерва по просроченной задолженности за "
      STRING(iDate) + "."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   /* сумма формируемого резерва */
   RUN SetSysConf IN h_base ("FlNotRound", "YES") .
   mFormRsrvSumm = LnFormRsrv(iContract,iContCode,iDate,iCurrency). 
   mFormRsrvSumm = CurrRound(mFormRsrvSumm,iCurrency).   
   RUN DeleteOldDataProtocol IN h_base ("FlNotRound").
   IF mFormRsrvSumm = 0.00 THEN  RETURN 0.00.

   /* сумма формируемого резерва по срочной задолженности */
   mFormRsrvSummFix = LnFormRsrvGoodDebt(iContract,iContCode,iDate,iCurrency).   
   mFormRsrvSummFix = CurrRound(mFormRsrvSummFix,iCurrency).
   IF mFormRsrvSumm = 0.00 THEN  RETURN 0.00.

   /* резерв по просроченной задолженности */
   mResult = mFormRsrvSumm - mFormRsrvSummFix.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
              AND mResult = 0) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Формируемый резерв по просроченной задолженности равен разнице между величиной общего формируемого резерва и "
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  величиной формируемого резерва по срочной задолженности."
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      "."
      mResult FORMAT "->>,>>>,>>>,>>>,>>9.<<<<<<<<<"
      " = "
      mFormRsrvSumm FORMAT "->>,>>>,>>>,>>>,>>9.<<<<<<<<<"
      " - "
      mFormRsrvSummFix FORMAT "->>,>>>,>>>,>>>,>>9.<<<<<<<<<"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Формируемый резерв по просроченной задолженности в валюте "
      iCurrency FORMAT "x(3)"
      ": "
      mResult FORMAT "->>,>>>,>>>,>>>,>>9.99"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvGoodDebtTransh
  Name       : Формируемый резерв по срочной задолженности
  Purpose    : возвращает часть суммы формируемого резерва, относящуюся к
               срочной задолженности по договору.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvGoodDebtTransh RETURNS DECIMAL (INPUT iContract AS CHAR,
                                                   INPUT iContCode AS CHAR,
                                                   INPUT iDate     AS DATE,
                                                   INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan FOR loan.

   DEF VAR mFormRsrvSumm AS DEC NO-UNDO.
   DEF VAR mBasicDebt AS DEC INIT 0 NO-UNDO.    /* основной долг по соглашению */
   DEF VAR mFixedDebt AS DEC INIT 0 NO-UNDO.    /* срочная задолженность */
   DEF VAR mResult    AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).
   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Расчет величины формируемого резерва по срочной задолженности за "
      STRING(iDate) + " (Режим: расчет по траншам)."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   /* сумма формируемого резерва */
   mFormRsrvSumm = LnFormRsrvTransh(iContract,iContCode,iDate,iCurrency).

   IF mFormRsrvSumm = 0.00 THEN  RETURN 0.00.

   ASSIGN
      /* сумма основного долга */
      mBasicDebt = LnPrincipal(iContract,iContCode,iDate,iCurrency)

      /* сумма срочной задолженности */
      mFixedDebt = LnGoodDebt(iContract,iContCode,iDate,iCurrency).

   IF mFixedDebt = mBasicDebt THEN
   DO:
      IF mIfPutPtot
         AND NOT(mIfPutNotNull
                 AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
                 AND mFixedDebt = 0) THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Нет просроченной задолженности. Формируемый резерв по срочной задолженности равен общему Формируемому резерву."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      RETURN mFormRsrvSumm.
   END.

   /* часть основного резерва, относящаяся к срочной задолженности */
   mResult = CurrRound ( mFormRsrvSumm * mFixedDebt / mBasicDebt, iCurrency ).

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
              AND mResult = 0) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Существует просроченная задолженность. Формируемый резерв по срочной задолженности будет рассчитан пропорционально:"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  [Формируемый резерв по срочной задолже.] = [Общий формируемый резерв] * [Срочная задолж.] / [Общая задолж.]"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      "."
      mResult FORMAT "->>,>>>,>>>,>>>,>>9.99"
      " = "
      mFormRsrvSumm FORMAT "->>,>>>,>>>,>>>,>>9.99"
      " * "
      mFixedDebt FORMAT "->>,>>>,>>>,>>>,>>9.99"
      " / "
      mBasicDebt FORMAT "->>,>>>,>>>,>>>,>>9.99"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Формируемый резерв по срочной задолженности в валюте "
      iCurrency FORMAT "x(3)"
      ": "
      mResult FORMAT "->>,>>>,>>>,>>>,>>9.99"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.
END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvBadDebtTransh
  Name       : Формируемый резерв по просроченной задолженности
  Purpose    : возвращает часть суммы формируемого резерва, относящуюся к
               просроченной задолженности по договору.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvBadDebtTransh RETURNS DECIMAL (INPUT iContract AS CHAR,
                                                  INPUT iContCode AS CHAR,
                                                  INPUT iDate     AS DATE,
                                                  INPUT iCurrency AS CHAR).
   DEF BUFFER b-loan FOR loan.

   DEF VAR mFormRsrvSumm    AS DEC NO-UNDO. /* формируемый резерв */
   DEF VAR mFormRsrvSummFix AS DEC NO-UNDO. /* формируемый резерв по срочной задол.*/
   DEF VAR mBasicDebt       AS DEC INIT 0 NO-UNDO. /* основной долг по соглашению */
   DEF VAR mFixedDebt       AS DEC INIT 0 NO-UNDO. /* срочная задолженность */
   DEF VAR mResult          AS DEC NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
       AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Расчет величины формируемого резерва по просроченной задолженности за "
      STRING(iDate) + " (Режим: расчет по траншам)."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   /* сумма формируемого резерва */
   mFormRsrvSumm = LnFormRsrvTransh(iContract,iContCode,iDate,iCurrency).
   IF mFormRsrvSumm = 0.00 THEN  RETURN 0.00.

   /* сумма формируемого резерва по срочной задолженности */
   mFormRsrvSummFix = LnFormRsrvGoodDebtTransh(iContract,iContCode,iDate,iCurrency).
   IF mFormRsrvSumm = 0.00 THEN  RETURN 0.00.

   /* резерв по просроченной задолженности */
   mResult = mFormRsrvSumm - mFormRsrvSummFix.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
              AND mResult = 0) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Формируемый резерв по просроченной задолженности равен разнице между величиной общего формируемого резерва и "
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  величиной формируемого резерва по срочной задолженности."
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      "."
      mResult FORMAT "->>,>>>,>>>,>>>,>>9.99"
      " = "
      mFormRsrvSumm
      " - "
      mFormRsrvSummFix FORMAT "->>,>>>,>>>,>>>,>>9.99"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Формируемый резерв по просроченной задолженности в валюте "
      iCurrency FORMAT "x(3)"
      ": "
      mResult FORMAT "->>,>>>,>>>,>>>,>>9.99"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.

END FUNCTION.

/*----------------------------------------------------------------------------
  Function   : LnGetGrRiska
  Purpose    : Определение группы риска по значению коэффициента резервирования
  Parameters : pPRsrv  - значение коэффициента резервирования
               iSince  - дата резервирования
               opGRsrv - возвращаемое значение группы риска
  Notes      :
  ----------------------------------------------------------------------------*/
FUNCTION LnGetGrRiska RETURNS INT64
  (pPRsrv AS DEC,
   iSince AS DATE):

   DEF VAR opGRsrv    AS INT64  INIT ?  NO-UNDO.

   RUN LnGetRiskGrOnDate (       pPRsrv,
                                 iSince,
                          OUTPUT opGRsrv).

   IF opGRsrv = ? THEN opGRsrv = 1.

   RETURN opGRsrv.
END.

/*----------------------------------------------------------------------------
  Function   : PsGetGrRiska
  Purpose    : Определение группы риска по значению коэффициента резервирования
               если договор относится к какому либо ПОСу
  Parameters : pPRsrv   - значение коэффициента резервирования
               iCustCat - тип клиента договора
               iSince   - дата резервирования
               opGRsrv  - возвращаемое значение группы риска
  Notes      :
  ----------------------------------------------------------------------------*/
FUNCTION PsGetGrRiska RETURNS INT64
  (iRate    AS DEC,
   iCustCat AS CHAR,
   iSince   AS DATE):

   DEF VAR vReturn AS INT64 INIT ? NO-UNDO.

   GetRefCrVal ("РезервПОС",
                "rate-comm",
                iSince,
                iCustCat,
                (TEMP-TABLE ttIndicate:HANDLE)).

   FOR EACH ttIndicate WHERE ttIndicate.fDec LE DEC(iRate) BY ttIndicate.fDec DESCENDING:
       LEAVE.
   END.

   IF AVAIL ttIndicate THEN
      vReturn = INT64(GetRefVal ("РезервПОС",iSince, iCustCat + "," + STRING(ttIndicate.fdec,">>9.99999"))).

   IF vReturn = ? THEN vReturn = 1.

   RETURN vReturn.
END.

/*---------------------------------------------------------------------------
  Function   : LnRsrvDate
  Name       :
  Purpose    : возвращает значение ставки резервирования по договору за
               указанную дату

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvDate RETURNS DATE   (
   INPUT iContract AS CHAR,
   INPUT iContCode AS CHAR,
   INPUT iDate     AS DATE
):
   DEF VAR vRate AS DEC    NO-UNDO.
   DEF VAR vPos  AS CHAR   NO-UNDO. /* Код ПОСа. */

   DEFINE BUFFER b-loan    FOR loan.
   DEFINE BUFFER comm-rate FOR comm-rate.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.
                        /* Если ссуда входит в ПОС, то определяем ставку по ПОСу. */
   vPos = LnInBagOnDate (b-loan.contract, b-loan.cont-code, iDate).
   IF vPos NE ?
   THEN DO:
      FIND FIRST loan WHERE
               loan.contract  EQ "ПОС"
         AND   loan.cont-code EQ vPos
      NO-LOCK NO-ERROR.
      IF AVAIL loan
         THEN RETURN DATE (fGetBagRate ((BUFFER loan:handle), "%Рез", iDate, "since")).
   END.
   /* поиск хронологически последнего коэффициента резервирования по договору */
   RUN GET_COMM_BUF IN h_comm ("%Рез",
                               ?,
                               b-loan.currency,
                               iContract + "," + iContCode,
                               0.00,
                               0,
                               iDate,
                               BUFFER comm-rate).

   IF AVAIL(comm-rate) THEN RETURN comm-rate.since.

   IF b-loan.cont-type = "Течение" THEN RETURN ?.

   /* договор не типа "течение" -> смотрим вышестоящий договор */
   IF NUM-ENTRIES(iContCode, " ") = 2
   THEN
      RETURN (LnRsrvDate (iContract,
                          ENTRY(1,iContCode, " "),
                          iDate)).

   RETURN ?.

END FUNCTION.



/*----------------------------------------------------------------------------
  Procedure  : LnGetRiskGrOnDate
  Purpose    : Определение группы риска по значению коэффициента резервирования
  Parameters : pPRsrv  - значение коэффициента резервирования
               iSince  - дата резервирования
               opGRsrv - возвращаемое значение группы риска
  Notes      : !!!!  Потом удалить использовать ф-цию
  ----------------------------------------------------------------------------*/

DEFINE TEMP-TABLE ttLoanGrRiska NO-UNDO
   FIELD since   AS DATE
   FIELD grRiska AS INT64
   FIELD minVal  AS DECIMAL
   FIELD maxVal  AS DECIMAL
   FIELD cldate  AS DATE

   INDEX idx since DESC cldate DESC minVal maxVal DESC
.
DEFINE VARIABLE mLoanGetGrInitialized AS LOGICAL    NO-UNDO INIT NO.


PROCEDURE LnGetRiskGrOnDate:
   DEFINE INPUT  PARAMETER pPRsrv  AS DECIMAL         NO-UNDO.
   DEFINE INPUT  PARAMETER iSince  AS DATE            NO-UNDO.
   DEFINE OUTPUT PARAMETER opGRsrv AS INT64 INIT ?  NO-UNDO.
   DEFINE VARIABLE vGRsrv AS CHARACTER   NO-UNDO.
   RUN LnGetRiskGrList(pPRsrv,iSince,NO,OUTPUT vGRsrv).
   IF vGRsrv NE ""
   THEN
      opGRsrv = INT64(vGRsrv).
END PROCEDURE.

PROCEDURE LnGetRiskGrList:
   DEFINE INPUT  PARAMETER pPRsrv  AS DECIMAL         NO-UNDO.
   DEFINE INPUT  PARAMETER iSince  AS DATE            NO-UNDO.
   DEFINE INPUT  PARAMETER iAll    AS LOGICAL         NO-UNDO.
   DEFINE OUTPUT PARAMETER opGRsrv AS CHARACTER       NO-UNDO.

   DEFINE BUFFER DataClass FOR DataClass.
   DEFINE BUFFER Formula   FOR formula.
   DEFINE BUFFER bformula  FOR formula. /* Локализация буфера. */
   DEFINE BUFFER ttGr      FOR ttLoanGrRiska.

   DEFINE VARIABLE mClDate AS DATE NO-UNDO.

   IF NOT mLoanGetGrInitialized THEN
   DO:
      EMPTY TEMP-TABLE ttLoanGrRiska.

      FOR FIRST DataClass WHERE
                DataClass.DataClass-ID EQ "Резерв"
      NO-LOCK:
         FOR EACH formula OF DataClass WHERE
                   formula.Misc[1] EQ Formula.DataClass-ID /* Формулы "первого" уровня. Родитель = misc[1] */
         NO-LOCK:
            FIND FIRST bformula WHERE bformula.DataClass-Id EQ formula.DataClass-Id
                                  AND bformula.var-id       EQ formula.var-id
                                  AND bformula.since        GT formula.since
               NO-LOCK NO-ERROR.
            IF AVAIL bformula
            THEN
               mClDate = bformula.since - 1.
            ELSE
               mClDate = DATE(GetXAttrValueEX("formula",formula.DataClass-ID + "," + formula.Var-ID, "close-date", "{&BQ-MAX-DATE}")).

            CREATE ttLoanGrRiska.
            ASSIGN
               ttLoanGrRiska.since   = formula.since
               ttLoanGrRiska.grRiska = INT64(SUBSTR(formula.var-id,1,1))
               ttLoanGrRiska.MinVal  = DEC (REPLACE (ENTRY (1,formula.formula),CHR(126),""))
               ttLoanGrRiska.MaxVal  = DEC (REPLACE (ENTRY (NUM-ENTRIES (formula.formula),formula.formula),CHR(126),""))
               ttLoanGrRiska.cldate  = mClDate
            .
            /* Если это последняя группа риска, то неравенство надо успростить */
            IF NUM-ENTRIES (formula.formula) EQ 1 THEN ttLoanGrRiska.MaxVal = ?.
            RELEASE ttLoanGrRiska.
         END.
      END.

      mLoanGetGrInitialized = YES.
   END.
/* Если дата не определена, устанавливаем дату на день раньше максимальной
** для поиска последней формулы */
   IF iSince = ? THEN iSince = DATE("{&BQ-MAX-DATE}") - 1.
/* Поиск нужной группы риска */
   Block-GrRisk:
   FOR EACH ttLoanGrRiska WHERE
              ttLoanGrRiska.MinVal LE pPRsrv
          AND(ttLoanGrRiska.MaxVal GE pPrsrv /* !!!GE не менять на GT, чтобы пользователь мог выбирать КК, попадающую на граничное значение */
              OR ttLoanGrRiska.MaxVal EQ ?)
          AND ttLoanGrRiska.since  LE iSince
          AND ttLoanGrRiska.cldate GT iSince
   NO-LOCK
      BY ttLoanGrRiska.grRiska DESCENDING:
/* Если нашли подходящую */
      IF NOT CAN-DO(opGRsrv,STRING(ttLoanGrRiska.grRiska))
      THEN
         opGRsrv = opGRsrv + (IF opGRsrv EQ "" THEN ""ELSE ",") + STRING(ttLoanGrRiska.grRiska).
      IF NOT iAll
      THEN 
          LEAVE Block-GrRisk. 
   END.
   /* Для корректного определения гр.риска старой даты, со значением 1.00000 */
   IF    opGRsrv EQ ""
     AND pPRsrv  EQ 1
     AND iSince  LE 08/01/2004 THEN
        opGRsrv = "1".
END PROCEDURE.

PROCEDURE LnGetPersRsrvOnDate:
   DEFINE INPUT  PARAMETER pGRsrv AS INT64    NO-UNDO.
   DEFINE INPUT  PARAMETER iSince AS DATE       NO-UNDO.
   DEFINE OUTPUT PARAMETER opRes  AS DECIMAL    NO-UNDO INIT ?.

   DEFINE VARIABLE vMax AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE vMin AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE vVal AS CHARACTER  NO-UNDO.

   DEFINE BUFFER formula FOR formula.
   /* Нулевая группа риска не существует */
   IF pGRsrv = 0 THEN
   DO:
      opRes = 0.
      RETURN.
   END.

   RUN Find_Formula (       "Резерв",
                            STRING(pGRsrv) + "гр",
                            iSince,
                            NO,
                     BUFFER formula).
   IF NOT AVAIL (formula) THEN RETURN.

   IF NUM-ENTRIES (vVal) >= 2 THEN
   DO:
      ASSIGN
         vVal = TRIM (formula.formula, CHR (126))  /* Отсекаем тильду */
         vMin = DEC (ENTRY (1,vVal))
         vMax = DEC (ENTRY (NUM-ENTRIES (vVal),vVal))
      NO-ERROR.
      /* Ошибка - не учитываем */
      IF ERROR-STATUS:ERROR THEN RETURN.
   END.
   ELSE
   DO:
      ASSIGN
         vVal = TRIM (formula.formula, CHR (126))  /* Отсекаем тильду */
         vMin = DEC (ENTRY (1,vVal))
      NO-ERROR.
      /* Ошибка - не учитываем */
      IF ERROR-STATUS:ERROR THEN RETURN.
   END.

   opRes = vMin.
END.

/* Определение группы риска договора на дату по истории. */
FUNCTION re_history_risk RETURNS INT64 (
   INPUT in_contract  AS CHARACTER,
   INPUT in_cont-code AS CHARACTER,
   INPUT ip_Date      AS DATE,
   INPUT ip_GrPrInt   AS INT64
):
   DEF VAR vReturnInt   AS INT64    NO-UNDO.
   DEF VAR vPos         AS CHAR   NO-UNDO. /* Код ПОСа. */
   DEF VAR vPosRate     AS DEC    NO-UNDO. /* Значение процентной ставки с ПОСа. */
   DEF VAR vSurCom      AS CHAR   NO-UNDO. /* Суррогаг ставки. */

   DEF BUFFER loan      FOR loan.      /* Локализация буфера. */
   DEF BUFFER comm-rate FOR comm-rate. /* Локализация буфера. */

   vReturnInt = ip_GrPrInt.
                        /* Если ссуда входит в ПОС, то определяем ставку по ПОСу. */
   vPos = LnInBagOnDate (in_contract, in_cont-code, ip_Date).
   IF vPos  NE ?
   THEN DO:
      FIND FIRST loan WHERE
               loan.contract  EQ "ПОС"
         AND   loan.cont-code EQ vPos
      NO-LOCK NO-ERROR.
      IF AVAIL loan
      THEN DO:
         FIND LAST comm-rate WHERE
                   comm-rate.commission EQ "%Рез"
               AND comm-rate.acct       EQ "0"
               AND comm-rate.currency   EQ ""
               AND comm-rate.kau        EQ "ПОС," + loan.cont-code
               AND comm-rate.min-value  EQ 0
               AND comm-rate.period     EQ 0 
               AND comm-rate.since      LE ip_Date
         NO-LOCK NO-ERROR.
         IF NOT AVAIL comm-rate 
            AND LENGTH(loan.parent-contract) GT 0 THEN
            FIND LAST comm-rate WHERE
                      comm-rate.commission EQ "%Рез"
                  AND comm-rate.acct       EQ "0"
                  AND comm-rate.currency   EQ ""
                  AND comm-rate.kau        EQ "ПОС," + loan.parent-cont-code
                  AND comm-rate.min-value  EQ 0
                  AND comm-rate.period     EQ 0 
                  AND comm-rate.since      LE ip_Date
            NO-LOCK NO-ERROR.
         IF AVAIL comm-rate THEN
         DO:
            vReturnInt = INT64 (GetXAttrValueEx("comm-rate",
                                                STRING(comm-rate.comm-rate-id),
                                                "КатегорияКач",
                                                ?)
                               ).
            IF vReturnInt EQ ? 
            THEN DO:
               vReturnInt = PsGetGrRiska (comm-rate.rate-comm,
                                          loan.cust-cat, 
                                          ip_Date).
               UpdateSigns("comm-rate",
                           STRING(comm-rate.comm-rate-id),
                           "КатегорияКач",
                           STRING(vReturnInt),
                           ?).
            END.
         END.
      END.
   END.
   ELSE DO:
      RUN GET_COMM_LOAN_BUF IN h_Loan (in_contract,
                                       in_cont-code,
                                       "%Рез",
                                       ip_date,
                                       BUFFER comm-rate).

      IF NOT AVAILABLE comm-rate              AND
         NUM-ENTRIES (in_cont-code, " ") = 2  AND
         NOT CAN-FIND (loan WHERE loan.contract  = in_contract
                              AND loan.cont-code = in_cont-code
                              AND loan.cont-type = "Течение"
                       NO-LOCK)
      THEN
         /* договор не типа "течение" -> смотрим вышестоящий договор */
         RUN GET_COMM_LOAN_BUF IN h_Loan (in_contract,
                                          ENTRY (1, in_cont-code, " "),
                                          "%Рез",
                                          ip_date,
                                          BUFFER comm-rate).
      IF AVAILABLE comm-rate
      THEN DO:
         vReturnInt = INT64 (GetXAttrValueEx("comm-rate",
                                           STRING(comm-rate.comm-rate-id),
                                           "КатегорияКач",
                                           ?)).
         IF vReturnInt EQ ?
         THEN
            vReturnInt = LnGetGrRiska(comm-rate.rate-comm,
                                      comm-rate.since).
      END.
   END.
   RETURN vReturnInt.
END FUNCTION.

/* Установка исторических значений группы риска и коэффициента резервирования */
PROCEDURE Set_Risk_From_History.
    DEF INPUT PARAM in_contract  AS CHARACTER NO-UNDO .
    DEF INPUT PARAM in_cont_code AS CHARACTER NO-UNDO .
    DEF INPUT PARAM ip_Date      AS DATE      NO-UNDO .
    DEF OUTPUT PARAM fl-o        AS INT64 NO-UNDO .

    DEF VAR grRisk  AS INT64 NO-UNDO .
    DEF VAR procRez AS DECIMAL NO-UNDO .
    DEF BUFFER loan FOR loan .
    DEF BUFFER yloan FOR loan .

    procRez = LnRsrvRate(in_contract,in_cont_code,ip_Date) .
    grRisk  = re_history_risk(in_contract,in_cont_code,ip_Date,1) .
    fl-o = -1.
    DO TRANSACTION ON ERROR UNDO, LEAVE ON ENDKEY UNDO, LEAVE :
      FIND FIRST loan WHERE loan.contract = in_contract AND loan.cont-code = in_cont_code EXCLUSIVE-LOCK NO-WAIT NO-ERROR .
      IF NOT AVAIL loan THEN LEAVE .
      ASSIGN loan.gr-riska = grRisk
             loan.risk     = procRez .
      /* Если договор - Течение нужно внести коррективы во все подчиненные
        договора- траншы, где нет переопределенных значений
        коэффициента резервирования */
      IF loan.cont-type = 'Течение'
      THEN RUN Set_Transh_Risk(loan.contract,loan.cont-code + ' ',
                               grRisk,procRez).
      fl-o  = 0.
    END.
END PROCEDURE .

PROCEDURE Set_Transh_Risk.
  DEF INPUT PARAM in_contract  AS CHAR NO-UNDO.
  DEF INPUT PARAM in_cont_code AS CHAR NO-UNDO .
  DEF INPUT PARAM in_gr        AS INT64 NO-UNDO .
  DEF INPUT PARAM in_risk      AS DECIMAL NO-UNDO .


  DEF BUFFER yloan FOR loan .
  DO TRANSACTION ON ERROR UNDO,RETURN ON ENDKEY UNDO,RETURN :
    FOR EACH yloan WHERE yloan.contract = in_contract
     AND yloan.cont-code begins in_cont_code :
     IF     GET_COMM ("%Рез",
                     ?,
                     yloan.currency,
                     in_contract + "," + yloan.cont-code,
                     0.00,
                     0,
                     01/01/3000) = ?
     THEN
        ASSIGN yloan.gr-riska = in_gr
               yloan.risk     = in_risk .
   END.
 END.
END PROCEDURE .

/*---------------------------------------------------------------------------
  Function   : LnPledgeQuality
  Name       : Стоимость объекта обеспечения
  Purpose    : возвращает стоимость объекта обеспечения с учетом значений
               коэффициента снижения стоимости и индекса качества обеспечения.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iIdnt       - идентификатор
               iEndDate    - срок
               iNN         - ?
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnPledgeQuality RETURNS DECIMAL (INPUT iContract AS CHAR,
                                          INPUT iContCode AS CHAR,
                                          INPUT iIdnt     AS INT64,
                                          INPUT iEndDate  AS DATE,
                                          INPUT iNN       AS INT64,
                                          INPUT iDate     AS DATE,
                                          INPUT iCurrency AS CHAR).

   DEF VAR mDRGQ     AS CHAR NO-UNDO. /*ДР term-obl.КачествоОбесп */
   DEF VAR mDRInDate AS CHAR NO-UNDO. /*ДР term-obl.ДатаПост */
   DEF VAR mGQIndex  AS DEC  NO-UNDO. /*индекс качества обеспечения*/
   DEF VAR mDecrRate AS DEC  NO-UNDO. /*коэффициент снижения качества обеспечения*/
   DEF VAR mGObjCost AS DEC  NO-UNDO. /*стоимость объекта обеспечения*/
   DEF VAR mGOSumm   AS DEC  NO-UNDO. /*сумма обеспечения по объекту*/
   DEF VAR mGQCode   AS CHAR NO-UNDO.
   DEF VAR mTotSumm  AS DEC  NO-UNDO.

   DEFINE BUFFER b-loan FOR loan.
   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   ASSIGN
      /* значение ДР КачествоОбесп */
      mDRGQ = Get_QualityGar("comm-rate",
                             iContract + "," + iContCode + ","
                           + STRING(iIdnt) + ","
                           + STRING(iEndDate) + ","
                           + STRING(iNN),
                             iDate)

      /* значение ДР "ДатаПост */
      mDRInDate = GetXAttrValue("term-obl",
                                iContract + "," + iContCode + ","
                              + STRING(iIdnt) + ","
                              + STRING(iEndDate) + ","
                              + STRING(iNN),
                                "ДатаПост").

   IF (mDRInDate <> "?" AND mDRInDate <> ? AND mDRInDate <> "" AND DATE(mDRInDate) > iDate)
      OR mDRGQ = "?" OR mDRGQ = ? OR mDRGQ = ""
   THEN
      RETURN 0.00.

   IF GetSysConf("Без_учета_категории_качества") EQ "yes" 
   THEN
      mGQIndex = 100.
   ELSE DO:
   /* индекс качества обеспечения по классификатору "КачествоОбесп"*/
      mGQIndex  = DEC(GetCode("КачествоОбесп", mDRGQ )).

      IF mGQIndex < 0 OR mGQIndex > 100 THEN DO:
         IF mIfPutPtot THEN
         DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
            "Ошибка      Договор: " b-loan.doc-ref FORMAT "X(22)"
            ".  Некорректное значение индекса качества обеспечения. Значение индекса качества обеспечения принимается равным нулю.".
         OUTPUT STREAM out_s CLOSE.
         END.
         mGQIndex = 0.
      END.
   END.
   /* mDecrRate - коэфф.снижения стоимости обеспечения (выполняется поиск
      коэффициента, установленного по объекту обеспечения на дату iDate)
   */
   mDecrRate = GET_COMM("Обесп",
                        ?,
                        iCurrency,
                        iContract + "," + iContCode + ","
                        + STRING(iIdnt) + ","
                        + STRING(iEndDate) + ","
                        + STRING(iNN),
                        0.00,
                        0,
                        iDate).

   IF mDecrRate = ? THEN mDecrRate = 100.
   IF mGQIndex  = ? THEN mGQIndex  = 0.

   ASSIGN
      /* стоимость объекта обеспечения */
      mGObjCost = LnPledge(iContract, iContCode, iIdnt, iEndDate, iNN,
                           iDate, ?, iCurrency)
      /* сумма обеспечения по объекту */
      mGOSumm  = mGObjCost * mGQIndex / 100 * mDecrRate / 100
      mGOSumm  = CurrRound ( mGOSumm, iCurrency )
      mTotSumm = mTotSumm + mGOSumm.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
              AND mTotSumm = 0) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  [Стоим. обесп. дог.] = [Стоим. объекта обесп.] * [Индекс качества] * [Коэф. остаточной стоим.]"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      "."
      mGOSumm   FORMAT "->>>>,>>>,>>>,>>9.99"
      " = "
      mGObjCost FORMAT "->>>>,>>>,>>>,>>9.99"
      " * "
      mGQIndex  FORMAT "->>>>,>>>,>>>,>>9.99"
      " % * "
      mDecrRate FORMAT "->>>>,>>>,>>>,>>9.99"
      SKIP
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Стоимость обеспечения по договору в валюте "
      iCurrency FORMAT "x(3)"
      ": "
      mTotSumm  FORMAT "->>>>,>>>,>>>,>>9.99999"
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mTotSumm.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : RegulationNeed
  Name       : Функция фиксирующая изменение факторов, влияющих на размер
               резерва.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iPrevDate   - дата предыдущего урегулирования резерва
               iCurrDate   - дата текущего урегулирования резерва
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION RegulationNeed RETURNS LOGICAL (INPUT iContract AS CHAR,
                                         INPUT iContCode AS CHAR,
                                         INPUT iPrevDate AS DATE,
                                         INPUT iCurrDate AS DATE).

   DEFINE BUFFER b-loan FOR loan.
   DEFINE BUFFER b-upper-loan FOR loan.

   DEFINE VAR vPrevRsrvRate     AS DECIMAL NO-UNDO.
   DEFINE VAR vCurrRsrvRate     AS DECIMAL NO-UNDO.
   DEFINE VAR vPrevPledgeSum    AS DECIMAL NO-UNDO.
   DEFINE VAR vCurrPledgeSum    AS DECIMAL NO-UNDO.
   DEFINE VAR vPrevPrnAmt       AS DECIMAL NO-UNDO.
   DEFINE VAR vCurrPrnAmt       AS DECIMAL NO-UNDO.
   DEFINE VAR vPrevPrnAmtTr     AS DECIMAL NO-UNDO.
   DEFINE VAR vCurrPrnAmtTr     AS DECIMAL NO-UNDO.
   DEFINE VAR vPrevTotPrnAmt    AS DECIMAL NO-UNDO.
   DEFINE VAR vCurrTotPrnAmt    AS DECIMAL NO-UNDO.
   DEFINE VAR vPrevGoodSum      AS DECIMAL NO-UNDO.
   DEFINE VAR vCurrGoodSum      AS DECIMAL NO-UNDO.
   DEFINE VAR vPrevBadSum       AS DECIMAL NO-UNDO.
   DEFINE VAR vCurrBadSum       AS DECIMAL NO-UNDO.
   DEFINE VAR vSummParCurr      AS DECIMAL NO-UNDO.
   DEFINE VAR vSummParPrev      AS DECIMAL NO-UNDO.
   DEFINE VAR vSumm-Db          AS DECIMAL NO-UNDO. /* Необходима для вызова STNDRT_PARAM */
   DEFINE VAR vSumm-Cr          AS DECIMAL NO-UNDO. /* Необходима для вызова STNDRT_PARAM */

   RUN RE_B_LOAN IN h_Loan (iContract, iContCode, BUFFER b-loan).

   IF NOT AVAIL b-loan THEN RETURN FALSE.

   /* проверка изменения основного долга */
   ASSIGN
      vPrevGoodSum = LnGoodDebt(iContract,
                                iContCode,
                                iPrevDate,
                                b-loan.currency)
      vCurrGoodSum = LnGoodDebt(iContract,
                                iContCode,
                                iCurrDate,
                                b-loan.currency)
      .

   IF vPrevGoodSum <> vCurrGoodSum THEN  RETURN TRUE.

   ASSIGN
       vPrevBadSum = LnBadDebt(iContract,
                              iContCode,
                              iPrevDate,
                              b-loan.currency)
      vCurrBadSum = LnBadDebt(iContract,
                              iContCode,
                              iCurrDate,
                              b-loan.currency)
      .

   IF vPrevBadSum <> vCurrBadSum THEN  RETURN TRUE.

   /* Проверки на движение по процентам ( 33 параметр ) */
   RUN STNDRT_PARAM(iContract,
                    iContCode,
                    33,
                    iPrevDate,
                    OUTPUT vSummParPrev,
                    OUTPUT vSumm-Db,
                    OUTPUT vSumm-Cr).
   RUN STNDRT_PARAM(iContract,
                    iContCode,
                    33,
                    iCurrDate,
                    OUTPUT vSummParCurr,
                    OUTPUT vSumm-Db,
                    OUTPUT vSumm-Cr).

   IF vSummParCurr <> vSummParPrev THEN RETURN TRUE.

   /* Проверки на изменение расчетной базы по процентам с учетом операций по погашению ( 35 параметр ) */
   RUN STNDRT_PARAM(iContract,
                    iContCode,
                    35,
                    iPrevDate,
                    OUTPUT vSummParPrev,
                    OUTPUT vSumm-Db,
                    OUTPUT vSumm-Cr).
   RUN STNDRT_PARAM(iContract,
                    iContCode,
                    35,
                    iCurrDate,
                    OUTPUT vSummParCurr,
                    OUTPUT vSumm-Db,
                    OUTPUT vSumm-Cr).

   IF vSummParCurr <> vSummParPrev THEN RETURN TRUE.

   /* Проверки на движение по процентам ( 10 параметр ) */
   RUN STNDRT_PARAM(iContract,
                    iContCode,
                    10,
                    iPrevDate,
                    OUTPUT vSummParPrev,
                    OUTPUT vSumm-Db,
                    OUTPUT vSumm-Cr).
   RUN STNDRT_PARAM(iContract,
                    iContCode,
                    10,
                    iCurrDate,
                    OUTPUT vSummParCurr,
                    OUTPUT vSumm-Db,
                    OUTPUT vSumm-Cr).

   IF vSummParCurr <> vSummParPrev THEN RETURN TRUE.

   /* Проверки на движение по свободному лимиту процентам ( 19 параметр ) */
   RUN STNDRT_PARAM(iContract,
                    iContCode,
                    19,
                    iPrevDate,
                    OUTPUT vSummParPrev,
                    OUTPUT vSumm-Db,
                    OUTPUT vSumm-Cr).
   RUN STNDRT_PARAM(iContract,
                    iContCode,
                    19,
                    iCurrDate,
                    OUTPUT vSummParCurr,
                    OUTPUT vSumm-Db,
                    OUTPUT vSumm-Cr).
   IF vSummParCurr <> vSummParPrev THEN RETURN TRUE.


   /* проверка изменения основного коэффициента создания резерва */
   vPrevRsrvRate = LnRsrvRate(iContract, iContCode, iPrevDate).
   vCurrRsrvRate = LnRsrvRate(iContract, iContCode, iCurrDate).

   IF vPrevRsrvRate <> vCurrRsrvRate THEN RETURN TRUE.

   /* проверка изменения стоимости обеспечения */
   FOR EACH term-obl WHERE
            term-obl.contract  = iContract
        AND term-obl.cont-code = iContCode
        AND term-obl.idnt      = 5
        AND ((term-obl.sop-date  > iPrevDate) OR
             (term-obl.sop-date  = ?))
   NO-LOCK:
      vPrevPledgeSum = LnPledgeQuality(iContract,
                                       iContCode,
                                       term-obl.idnt,
                                       term-obl.end-date,
                                       term-obl.nn,
                                       iPrevDate,
                                       term-obl.currency).

      vCurrPledgeSum = LnPledgeQuality(iContract,
                                       iContCode,
                                       term-obl.idnt,
                                       term-obl.end-date,
                                       term-obl.nn,
                                       iCurrDate,
                                       term-obl.currency).

      IF vPrevPledgeSum <> vCurrPledgeSum THEN RETURN TRUE.

   END. /*FOR EACH*/

   IF b-loan.cont-type = "Течение" THEN
   DO:
      FOR EACH loan WHERE loan.contract = iContract
                      AND loan.cont-code BEGINS iContCode
                      AND NUM-ENTRIES(loan.cont-code, " ") = 2
                      AND ENTRY(1, loan.cont-code, " ") = iContCode
                      AND loan.open-date <= iCurrDate
      NO-LOCK:

         FOR EACH term-obl WHERE
                  term-obl.contract  = loan.contract
              AND term-obl.cont-code = loan.cont-code
              AND term-obl.idnt      = 5
              AND ((term-obl.sop-date  > iPrevDate) OR
                   (term-obl.sop-date = ?))
         NO-LOCK:
            vPrevPledgeSum = LnPledgeQuality(loan.contract,
                                             loan.cont-code,
                                             term-obl.idnt,
                                             term-obl.end-date,
                                             term-obl.nn,
                                             iPrevDate,
                                             term-obl.currency).

            vCurrPledgeSum = LnPledgeQuality(loan.contract,
                                             loan.cont-code,
                                             term-obl.idnt,
                                             term-obl.end-date,
                                             term-obl.nn,
                                             iCurrDate,
                                             term-obl.currency).

            IF vPrevPledgeSum <> vCurrPledgeSum THEN RETURN TRUE.

         END. /*FOR EACH term-obl*/

      END. /*FOR EACH loan*/

   END. /*IF "Течение"*/
   ELSE DO:
      /* Проверка - не является ли текущий договор траншем вышестоящего
         договора. Если да, то проверяется изменение суммы обеспечения,
         зарегистрированного на вышестоящем договоре и относящегося к
         данному траншу.
      */

      IF NUM-ENTRIES(iContCode, " ") = 2 THEN DO:

         FIND FIRST b-upper-loan WHERE
                    b-upper-loan.contract  = iContract
                AND b-upper-loan.cont-code = ENTRY(1, iContCode, " ")
                AND b-upper-loan.cont-type = "Течение"
         NO-LOCK NO-ERROR.

         IF AVAIL(b-upper-loan) THEN DO:
            /*
               Во-первых, требует проверки изменение оценки обеспечения
               (в валюте этого обеспечения) по вышестоящему договору.
            */

            FOR EACH term-obl WHERE
                     term-obl.contract  = b-upper-loan.contract
                 AND term-obl.cont-code = b-upper-loan.cont-code
                 AND term-obl.idnt      = 5
                 AND ((term-obl.sop-date  > iPrevDate) OR
                      (term-obl.sop-date = ?))
            NO-LOCK:
               vPrevPledgeSum = LnPledgeQuality(b-upper-loan.contract,
                                                b-upper-loan.cont-code,
                                                term-obl.idnt,
                                                term-obl.end-date,
                                                term-obl.nn,
                                                iPrevDate,
                                                term-obl.currency).

               vCurrPledgeSum = LnPledgeQuality(b-upper-loan.contract,
                                                b-upper-loan.cont-code,
                                                term-obl.idnt,
                                                term-obl.end-date,
                                                term-obl.nn,
                                                iCurrDate,
                                                term-obl.currency).

               IF vPrevPledgeSum <> vCurrPledgeSum THEN RETURN TRUE.

            END. /*FOR EACH term-obl*/

            /*
               Во-вторых, требует проверки изменение доли основного долга,
               относящейся к текущему течению, в общей задолженности
               по всем траншам. Изменение может быть вызвано, например,
               выдачей нового транша.
            */

            /* задолженность по основному долгу по текущему договору */
            vPrevPrnAmt = LnPrincipal(iContract,iContCode,
                                      iPrevDate,b-loan.currency).

            vCurrPrnAmt = LnPrincipal(iContract,iContCode,
                                      iCurrDate,b-loan.currency).

            /* для всех течений вышестоящего договора, кроме тех, которые открыты
               позже iPrevDate или закрыты ранее iPrevDate
            */
            FOR EACH loan WHERE
                     loan.contract = b-upper-loan.contract
                 AND loan.cont-code BEGINS b-upper-loan.cont-code
                 AND NUM-ENTRIES(loan.cont-code, " ") = 2
                 AND ENTRY(1, loan.cont-code, " ") = b-upper-loan.cont-code
                 AND b-loan.open-date <= iPrevDate
            NO-LOCK:

               IF loan.close-date <> ? AND loan.close-date <= iPrevDate THEN NEXT.

               /* размер ссуды по очередному течению */
               vPrevPrnAmtTr = LnPrincipal(loan.contract,loan.cont-code,
                                           iPrevDate,loan.currency).
               /* размер ссуды по соглашению */
               vPrevTotPrnAmt = vPrevTotPrnAmt +  vPrevPrnAmtTr.
            END.

            /* для всех течений вышестоящего договора, кроме тех, которые открыты
               позже iCurrDate или закрыты ранее iCurrDate
            */
            FOR EACH loan WHERE
                     loan.contract = b-upper-loan.contract
                 AND loan.cont-code BEGINS b-upper-loan.cont-code
                 AND NUM-ENTRIES(loan.cont-code, " ") = 2
                 AND ENTRY(1, loan.cont-code, " ") = b-upper-loan.cont-code
                 AND b-loan.open-date <= iCurrDate
            NO-LOCK:

               IF loan.close-date <> ? AND loan.close-date <= iCurrDate THEN NEXT.

               /* размер ссуды по очередному течению */
               vCurrPrnAmtTr = LnPrincipal(loan.contract,loan.cont-code,
                                           iCurrDate,loan.currency).
               /* размер ссуды по соглашению */
               vCurrTotPrnAmt = vCurrTotPrnAmt +  vCurrPrnAmtTr.
            END.

            IF (vPrevTotPrnAmt > 0) AND (vCurrTotPrnAmt > 0) THEN
               IF (vPrevPrnAmt / vPrevTotPrnAmt) NE
                  (vCurrPrnAmt / vCurrTotPrnAmt) THEN RETURN YES.

            IF (vPrevTotPrnAmt > 0) AND (vCurrTotPrnAmt = 0) THEN RETURN YES.
            IF (vPrevTotPrnAmt = 0) AND (vCurrTotPrnAmt > 0) THEN RETURN YES.

         END.

      END.

   END.

   RETURN FALSE.

END FUNCTION.

/*=*/
/*---------------------------------------------------------------------------
  Function   : LnRsrvBal
  Name       : Остаток резерва
  Purpose    : возвращает остаток резерва по срочной и просроченной задолженности,
               фактически созданного по договору, на указанную дату.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvBal RETURNS DECIMAL (INPUT iContract AS CHAR,
                                    INPUT iContCode AS CHAR,
                                    INPUT iDate     AS DATE,
                                    INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan FOR loan.

   DEF VAR mspar      AS CHAR NO-UNDO. /* список параметров */
   DEF VAR mi         AS INT64  NO-UNDO.
   DEF VAR mpar       AS INT64  NO-UNDO.
   DEF VAR mLoanCurr  AS CHAR NO-UNDO. /* валюта договора */
   DEF VAR vParamSumm AS DEC  NO-UNDO.
   DEF VAR vDb        AS DEC  NO-UNDO.
   DEF VAR vCr        AS DEC  NO-UNDO.
   DEF VAR vRes       AS DEC  NO-UNDO.
   DEF VAR mResult    AS DEC  NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   mspar = "21,46". /* параметры для расчета резерва по договору */

   DO mi = 1 TO NUM-ENTRIES(mspar):

      mpar = INT64(ENTRY(mi,mspar)).

      RUN RE_PARAM IN h_Loan ( mpar,                 /* Код параметра */
                               iDate,                /* Дата расчета */
                               iContract,            /* Тип договора */
                               iContCode,            /* Номер договора */
                               OUTPUT vParamSumm,    /* Сумма параметра */
                               OUTPUT vDb,           /* Дебет обороты */
                               OUTPUT vCr).          /* Кредитовые обороты */

      vRes = vRes + vParamSumm.

   END.

   IF iCurrency <> "" THEN
      vRes = CurToCurWork("Учетный", "", iCurrency, iDate, vRes).

   mResult = CurrRound(vRes,iCurrency).

   IF mResult < 0.00 THEN mResult = ABSOLUTE(mResult).
                     ELSE mResult = 0.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
              AND vRes = 0)  THEN
   DO:
       OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Вычисление остатка резерва, фактически созданного по договору, за "
          STRING(iDate, "99/99/9999") + "."
          SKIP.

       DO mi = 1 TO NUM-ENTRIES(mspar):
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
             ".  Параметр "
             mpar FORMAT ">9"
             ". Остаток в национальной валюте: "
             vParamSumm FORMAT "->>>,>>>,>>>,>>9.99"
             SKIP.
       END.

       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Величина остатка резерва, фактически созданного по договору, в валюте "
          iCurrency FORMAT "x(3)"
          ": "
          mResult FORMAT "->>>,>>>,>>>,>>9.99"
          SKIP.
       OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnRsrvBalGoodDebt
  Name       : Остаток резерва
  Purpose    : возвращает остаток резерва по срочной задолженности, фактически
               созданного по договору, на указанную дату.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvBalGoodDebt RETURNS DECIMAL (INPUT iContract AS CHAR,
                                            INPUT iContCode AS CHAR,
                                            INPUT iDate     AS DATE,
                                            INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan FOR loan.

   DEF VAR mpar       AS INT64  NO-UNDO.
   DEF VAR mLoanCurr  AS CHAR NO-UNDO. /* валюта договора */
   DEF VAR vParamSumm AS DEC  NO-UNDO.
   DEF VAR vDb        AS DEC  NO-UNDO.
   DEF VAR vCr        AS DEC  NO-UNDO.
   DEF VAR vRes       AS DEC  NO-UNDO.
   DEF VAR mResult    AS DEC  NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   mpar = 21. /* параметр для расчета резерва */

   RUN RE_PARAM IN h_Loan ( mpar,                 /* Код параметра */
                            iDate,                /* Дата расчета */
                            iContract,            /* Тип договора */
                            iContCode,            /* Номер договора */
                            OUTPUT vParamSumm,    /* Сумма параметра */
                            OUTPUT vDb,           /* Дебет обороты */
                            OUTPUT vCr).          /* Кредитовые обороты */

   vRes = vParamSumm.

   IF iCurrency <> "" THEN
      vRes = CurToCurWork("Учетный", "", iCurrency, iDate, vRes).

   mResult = CurrRound(vRes,iCurrency).

   IF mResult < 0.00 THEN mResult = ABSOLUTE(mResult).
                     ELSE mResult = 0.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
              AND vRes = 0)  THEN
   DO:
       OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Вычисление остатка резерва по срочной задолженности, фактически созданного по договору, за "
          STRING(iDate, "99/99/9999") + "."
          SKIP.


       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Параметр "
          mpar FORMAT ">9"
          ". Остаток в национальной валюте: "
          vParamSumm FORMAT "->>>,>>>,>>>,>>9.99"
          SKIP.

       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Величина остатка резерва по срочной задолженности, фактически созданного по договору, в валюте "
          iCurrency FORMAT "x(3)"
          ": "
          mResult FORMAT "->>>,>>>,>>>,>>9.99"
          SKIP.
       OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnRsrvBalBadDebt
  Name       : Остаток резерва
  Purpose    : возвращает остаток резерва по просроченной задолженности, фактически
               созданного по договору, на указанную дату.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvBalBadDebt RETURNS DECIMAL (INPUT iContract AS CHAR,
                                           INPUT iContCode AS CHAR,
                                           INPUT iDate     AS DATE,
                                           INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan FOR loan.

   DEF VAR mpar       AS INT64  NO-UNDO.
   DEF VAR mLoanCurr  AS CHAR NO-UNDO. /* валюта договора */
   DEF VAR vParamSumm AS DEC  NO-UNDO.
   DEF VAR vDb        AS DEC  NO-UNDO.
   DEF VAR vCr        AS DEC  NO-UNDO.
   DEF VAR vRes       AS DEC  NO-UNDO.
   DEF VAR mResult    AS DEC  NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   mpar = 46. /* параметр для расчета резерва */

   RUN RE_PARAM IN h_Loan ( mpar,                 /* Код параметра */
                            iDate,                /* Дата расчета */
                            iContract,            /* Тип договора */
                            iContCode,            /* Номер договора */
                            OUTPUT vParamSumm,    /* Сумма параметра */
                            OUTPUT vDb,           /* Дебет обороты */
                            OUTPUT vCr).          /* Кредитовые обороты */

   vRes = vParamSumm.

   IF iCurrency <> "" THEN
      vRes = CurToCurWork("Учетный", "", iCurrency, iDate, vRes).

   mResult = CurrRound(vRes,iCurrency).

   IF mResult < 0.00 THEN mResult = ABSOLUTE(mResult).
                     ELSE mResult = 0.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2
              AND vRes = 0) THEN
   DO:
       OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Вычисление остатка резерва по просроченной задолженности, фактически созданного по договору, за "
          STRING(iDate, "99/99/9999") + "."
          SKIP.

       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Параметр "
          mpar FORMAT ">9"
          ". Остаток в национальной валюте: "
          vParamSumm FORMAT "->>>,>>>,>>>,>>9.99"
          SKIP.

       PUT STREAM out_s UNFORMATTED
          "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
          ".  Величина остатка резерва по просроченной задолженности, фактически созданного по договору, в валюте "
          iCurrency FORMAT "x(3)"
          ": "
          mResult FORMAT "->>>,>>>,>>>,>>9.99"
          SKIP.
       OUTPUT STREAM out_s CLOSE.
   END.

   RETURN mResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnRsrvBalTransh
  Name       : Остаток резерва
  Purpose    : возвращает остаток резерва по срочной и просроченной задолженности,
               фактически созданного по договору, на указанную дату. Если договор
               имеет тип "Течение" возвращает ноль.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvBalTransh RETURNS DECIMAL (INPUT iContract AS CHAR,
                                          INPUT iContCode AS CHAR,
                                          INPUT iDate     AS DATE,
                                          INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan    FOR loan.
   DEFINE BUFFER b-loan-up FOR loan.

   DEF VAR vPartRes   AS DEC  NO-UNDO.
   DEF VAR vRes       AS DEC  NO-UNDO.
   DEF VAR mResult    AS DEC  INIT ? NO-UNDO.
   DEF VAR vPos       AS DEC  NO-UNDO.
   DEF VAR vAgrPos    AS DEC  NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Вычисление остатка резерва, фактически созданного по договору, за "
      STRING(iDate, "99/99/9999") + " (Режим: расчет по траншам)."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.
   IF b-loan.cont-type = "Течение" THEN
   DO:
      IF mIfPutPtot THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Договор имеет тип 'Течение'. Для договоров такого вида остаток резерва считается равным нулю."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      RETURN 0.00.
   END.

   IF NUM-ENTRIES(b-loan.cont-code, " ") = 2 AND
      CAN-FIND( FIRST b-loan-up WHERE
                      b-loan-up.cont-type = "Течение"
                  AND b-loan-up.contract  = b-loan.contract
                  AND b-loan-up.cont-code = ENTRY(1,b-loan.cont-code, " ")
              )
   THEN
   DO:
      FIND FIRST b-loan-up WHERE
                 b-loan-up.cont-type = "Течение"
             AND b-loan-up.contract  = b-loan.contract
             AND b-loan-up.cont-code = ENTRY(1,b-loan.cont-code, " ")
         NO-LOCK NO-ERROR.

      IF CAN-DO(GetXAttrInit(b-loan-up.class-code,"rel_type"), "КредРез") THEN
      DO:
         vPos    = LnPrincipal(iContract, iContCode, iDate, iCurrency).
         vAgrPos = LnPrincipal(b-loan-up.contract,
                               b-loan-up.cont-code,
                               iDate,
                               iCurrency).

         /* доля резерва от созданного на вышестоящем договоре */
         vPartRes = IF vAgrPos = 0 THEN 0 ELSE vPos / vAgrPos.

         vRes = vPartRes * LnRsrvBal(b-loan-up.contract,
                                     b-loan-up.cont-code,
                                     iDate,
                                     iCurrency).
         mResult = Round(vRes,2).

      END.
   END.

   IF mResult = ? THEN
      mResult = LnRsrvBal(iContract, iContCode, iDate, iCurrency).

   RETURN mResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnRsrvBalGoodDebtTransh
  Name       : Остаток резерва по срочной задолженности
  Purpose    : возвращает остаток резерва по срочной задолженности, фактически
               созданного по договору, на указанную дату. Если договор имеет
               тип "Течение" возвращает ноль.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvBalGoodDebtTransh RETURNS DECIMAL (INPUT iContract AS CHAR,
                                                  INPUT iContCode AS CHAR,
                                                  INPUT iDate     AS DATE,
                                                  INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan    FOR loan.
   DEFINE BUFFER b-loan-up FOR loan.

   DEF VAR vPartRes   AS DEC  NO-UNDO.
   DEF VAR vRes       AS DEC  NO-UNDO.
   DEF VAR mResult    AS DEC  INIT ? NO-UNDO.
   DEF VAR vPos       AS DEC  NO-UNDO.
   DEF VAR vAgrPos    AS DEC  NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Вычисление остатка резерва по срочной задолженности, фактически созданного по договору, за "
      STRING(iDate, "99/99/9999") + " (Режим: расчет по траншам)."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   IF b-loan.cont-type = "Течение" THEN
   DO:
      IF mIfPutPtot THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Договор имеет тип 'Течение'. Для договоров такого вида остаток резерва считается равным нулю."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      RETURN 0.00.
   END.

   IF NUM-ENTRIES(b-loan.cont-code, " ") = 2 AND
      CAN-FIND( FIRST b-loan-up WHERE
                      b-loan-up.cont-type = "Течение"
                  AND b-loan-up.contract  = b-loan.contract
                  AND b-loan-up.cont-code = ENTRY(1,b-loan.cont-code, " ")
              )
   THEN
   DO:
      FIND FIRST b-loan-up WHERE
                 b-loan-up.cont-type = "Течение"
             AND b-loan-up.contract  = b-loan.contract
             AND b-loan-up.cont-code = ENTRY(1,b-loan.cont-code, " ")
         NO-LOCK NO-ERROR.

      IF CAN-DO(GetXAttrInit(b-loan-up.class-code,"rel_type"), "КредРез") THEN
      DO:
         vPos     = LnGoodDebt(iContract, iContCode, iDate, iCurrency).
         vAgrPos  = LnGoodDebt(b-loan-up.contract,
                               b-loan-up.cont-code,
                               iDate,
                               iCurrency).

         /* доля резерва от созданного на вышестоящем договоре */
         vPartRes = IF vAgrPos = 0 THEN 0 ELSE vPos / vAgrPos.

         vRes = vPartRes * LnRsrvBalGoodDebt(b-loan-up.contract,
                                             b-loan-up.cont-code,
                                             iDate,
                                             iCurrency).
         mResult = Round(vRes,2).

      END.
   END.

   IF mResult = ? THEN
      mResult = LnRsrvBalGoodDebt(iContract, iContCode, iDate, iCurrency).

   RETURN mResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnRsrvBalBadDebtTransh
  Name       : Остаток резерва по просроченной задолженности
  Purpose    : возвращает остаток резерва по просроченной задолженности, фактически
               созданного по договору, на указанную дату. Если договор имеет
               тип "Течение" возвращает ноль.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvBalBadDebtTransh RETURNS DECIMAL (INPUT iContract AS CHAR,
                                                 INPUT iContCode AS CHAR,
                                                 INPUT iDate     AS DATE,
                                                 INPUT iCurrency AS CHAR).
   DEFINE BUFFER b-loan    FOR loan.
   DEFINE BUFFER b-loan-up FOR loan.

   DEF VAR vPartRes   AS DEC  NO-UNDO.
   DEF VAR vRes       AS DEC  NO-UNDO.
   DEF VAR mResult    AS DEC  INIT ? NO-UNDO.
   DEF VAR vPos       AS DEC  NO-UNDO.
   DEF VAR vAgrPos    AS DEC  NO-UNDO.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(b-loan.doc-ref, " ") = 2) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
      ".  Вычисление остатка резерва по просроченной задолженности, фактически созданного по договору, за "
      STRING(iDate, "99/99/9999") + " (Режим: расчет по траншам)."
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   IF b-loan.cont-type = "Течение" THEN
   DO:
      IF mIfPutPtot THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " b-loan.doc-ref FORMAT "X(22)"
         ".  Договор имеет тип 'Течение'. Для договоров такого вида остаток резерва считается равным нулю."
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      RETURN 0.00.
   END.

   IF NUM-ENTRIES(b-loan.cont-code, " ") = 2 AND
      CAN-FIND( FIRST b-loan-up WHERE
                      b-loan-up.cont-type = "Течение"
                  AND b-loan-up.contract  = b-loan.contract
                  AND b-loan-up.cont-code = ENTRY(1,b-loan.cont-code, " ")
              )
   THEN
   DO:
      FIND FIRST b-loan-up WHERE
                 b-loan-up.cont-type = "Течение"
             AND b-loan-up.contract  = b-loan.contract
             AND b-loan-up.cont-code = ENTRY(1,b-loan.cont-code, " ")
         NO-LOCK NO-ERROR.

      IF CAN-DO(GetXAttrInit(b-loan-up.class-code,"rel_type"), "КредРез") THEN
      DO:
         vPos    = LnBadDebt(iContract, iContCode, iDate, iCurrency).
         vAgrPos = LnBadDebt(b-loan-up.contract,
                             b-loan-up.cont-code,
                             iDate,
                             iCurrency).

         /* доля резерва от созданного на вышестоящем договоре */
         vPartRes = IF vAgrPos = 0 THEN 0 ELSE vPos / vAgrPos.

         vRes = vPartRes * LnRsrvBalBadDebt(b-loan-up.contract,
                                            b-loan-up.cont-code,
                                            iDate,
                                            iCurrency).
         mResult = Round(vRes,2).

      END.
   END.

   IF mResult = ? THEN
      mResult = LnRsrvBalBadDebt(iContract, iContCode, iDate, iCurrency).

   RETURN mResult.

END FUNCTION.

/*----------------------------------------------------------------------------

  Procedure  : LnTurnoverDb
  Name       : Расчет суммарного оборота по выдаче кредита и переоценке с начала
               месяца.
  Purpose    : Расчет величины суммарного оборота по предоставлению ссуды и
               положительной переоценке с начала отчетного месяца.
               Возвращает величины:
               - Суммарный оборот по выдаче ссуды, в валюте результата(oTurnoverDb);
               - Суммарный оборот по положительной переоценке ссуды, в валюте
                 результата(VRevalDb);
               - Количество операционных дней с начала месяца по дату расчета (oCounter).
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
               oTurnoverDb - суммарный оборот по выдаче ссуды в валюте результата
               oRevalDb    - суммарный оборот по положительной переоценке ссуды в
                             валюте результата
               oCounter    - количество операционных дней с начала месяца по дату
                             расчета
  Notes      :
  ----------------------------------------------------------------------------*/
PROCEDURE LnTurnoverDb.
   DEF INPUT  PARAM iContract    AS CHARACTER NO-UNDO.
   DEF INPUT  PARAM iContCode    AS CHARACTER NO-UNDO.
   DEF INPUT  PARAM iDate        AS DATE      NO-UNDO.
   DEF INPUT  PARAM iCurrency    AS CHARACTER NO-UNDO.
   DEF OUTPUT PARAM oTurnoverDb  AS DECIMAL   NO-UNDO.
   DEF OUTPUT PARAM oRevalDb     AS DECIMAL   NO-UNDO.
   DEF OUTPUT PARAM oCounter     AS INT64   NO-UNDO.

   DEFINE BUFFER b-loan    FOR loan.
   DEFINE BUFFER b-op-date FOR op-date.

   DEFINE VARIABLE vbDate        AS DATE     NO-UNDO.
   DEFINE VARIABLE vPrevOpDate   AS DATE     NO-UNDO.
   DEFINE VARIABLE vReval        AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vRevalDb      AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vSumDb        AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vPrincipalY   AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vLoanRateY    AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vLoanRateT    AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vCurRateY     AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vCurRateT     AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vFromFirstDay AS LOGICAL  NO-UNDO.
   DEFINE VARIABLE vByCalendDays AS LOGICAL  NO-UNDO.
   DEFINE VARIABLE vFromOpenDate AS LOGICAL  NO-UNDO.
   DEFINE VARIABLE vDaysNbr      AS INT64  NO-UNDO.
   DEFINE VARIABLE vspar         AS CHAR NO-UNDO. /* список параметров */
   DEFINE VARIABLE oResVer    AS CHARACTER NO-UNDO .
   DEFINE VARIABLE oResVerP    AS CHARACTER NO-UNDO .

   vspar = "0,7,13". /* параметры для расчета сумм остатков */
   Run GetSpisBaseParam IN THIS-PROCEDURE  (OUTPUT oResVer, OUTPUT oResVerP).
   IF oResVer <> "" THEN vspar = Trim(oResVer,",") + "," + Trim(oResVerP,",") .


   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN.
   END.

   vFromFirstDay = (FGetSetting("ОфшорРез","РасчетНачМес","Нет") = "Да").
   vByCalendDays = (FGetSetting("ОфшорРез","КалендДни","Да")     = "Да").
   vFromOpenDate = (FGetSetting("ОфшорРез","НачСделки","Да")     = "Да").

   vDaysNbr      = INT64(FGetSetting("ОфшорРез","ДнейВПериоде","30")) NO-ERROR.
   IF (vDaysNbr = ?) OR (vDaysNbr LE 0) THEN vDaysNbr = 30.

   vbDate = IF vFromFirstDay THEN FirstMonDate(iDate)
                             ELSE (iDate - vDaysNbr + 1).
   IF vFromOpenDate THEN vbDate = MAX(vbDate, b-loan.open-date).

   vDaysNbr = iDate - vbDate + 1.

   ASSIGN
      vRevalDb = 0.00
      vSumDb   = 0.00
      oCounter = 0.

   IF b-loan.cont-type <> "Течение" THEN

      FOR EACH b-op-date WHERE
               b-op-date.op-date >= vbDate
           AND b-op-date.op-date <= iDate
      NO-LOCK BY b-op-date.op-date:

         oCounter = oCounter + IF vFromOpenDate AND (b-op-date.op-date < b-loan.open-date) THEN 0 ELSE 1.

         /* дата предыдущего операционного дня */
         FIND LAST op-date WHERE op-date.op-date < b-op-date.op-date NO-LOCK NO-ERROR.

         vPrevOpDate = IF AVAIL op-date THEN op-date.op-date
                                        ELSE b-op-date.op-date.

         ASSIGN
           vLoanRateT = IF b-loan.Currency <> ""
                        THEN FindRate("Учетный", b-loan.Currency, b-op-date.op-date)
                        ELSE 1

           vCurRateT  = IF iCurrency <> ""
                        THEN FindRate("Учетный", iCurrency, b-op-date.op-date)
                        ELSE 1
           .

         IF b-op-date.op-date >= b-loan.open-date THEN DO:

            vRevalDb = 0.00.

            IF b-loan.Currency <> iCurrency THEN DO:
               /* величина основного долга по договору в валюте договора */
               vPrincipalY = LnPrincipal(iContract,iContCode,vPrevOpDate,b-loan.Currency).

               /* учетные курсы валюты договора и валюты результата за предыдущий и
                  текущий операционный день
               */
               ASSIGN
                  vLoanRateY = IF b-loan.Currency <> ""
                               THEN FindRate("Учетный", b-loan.Currency, vPrevOpDate)
                               ELSE 1

                  vCurRateY  = IF iCurrency <> ""
                               THEN FindRate("Учетный", iCurrency, vPrevOpDate)
                               ELSE 1
                  .

               /* величина переоценки основного долга в валюте результата */
               vReval = CurrRound(vPrincipalY * vLoanRateT / vCurRateT, iCurrency) -
                        CurrRound(vPrincipalY * vLoanRateY / vCurRateY, iCurrency).

               IF vReval > 0 THEN vRevalDb = vReval.
            END.

            vSumDb = 0.

            FOR EACH loan-int WHERE
                     loan-int.contract  = iContract
                 AND loan-int.cont-code = iContCode
                 AND loan-int.mdate     > vPrevOpDate
                 AND loan-int.mdate    <= b-op-date.op-date
                 AND loan-int.mdate    >= vbDate
                 AND loan-int.id-d = 0
                 AND NOT CAN-DO(vspar, STRING(loan-int.id-k))  /* 0,7,13 */
            NO-LOCK:
               vSumDb = vSumDb + IF vLoanRateT = vCurRateT THEN loan-int.amt-rub ELSE
                        CurrRound(loan-int.amt-rub * vLoanRateT / vCurRateT, iCurrency).
            END.

         END.

         ASSIGN
            oRevalDb    = oRevalDb + vRevalDb
            oTurnoverDb = oTurnoverDb + vSumDb.

      END. /*FOR EACH b-op-date*/


   ELSE /* Течение */

      FOR EACH b-op-date WHERE
               b-op-date.op-date >= vbDate
           AND b-op-date.op-date <= iDate
      NO-LOCK BY b-op-date.op-date:

         oCounter = oCounter + IF vFromOpenDate AND (b-op-date.op-date < b-loan.open-date) THEN 0 ELSE 1.

         /* дата предыдущего операционного дня */
         FIND LAST op-date WHERE op-date.op-date < b-op-date.op-date NO-LOCK NO-ERROR.

         vPrevOpDate = IF AVAIL op-date THEN op-date.op-date
                                        ELSE b-op-date.op-date.

         ASSIGN
            vLoanRateT = IF b-loan.Currency <> ""
                         THEN FindRate("Учетный", b-loan.Currency, b-op-date.op-date)
                         ELSE 1

            vCurRateT  = IF iCurrency <> ""
                         THEN FindRate("Учетный", iCurrency, b-op-date.op-date)
                         ELSE 1
            .

         FOR EACH loan WHERE
                  loan.contract = iContract
              AND loan.cont-code BEGINS iContCode
              AND NUM-ENTRIES(loan.cont-code, " ") = 2
              AND ENTRY(1, loan.cont-code, " ") = iContCode
              AND loan.open-date <= iDate
              AND NOT (loan.close-date <> ? AND loan.close-date <= vbDate)
         NO-LOCK:

            IF b-op-date.op-date >= loan.open-date THEN DO:

               vRevalDb = 0.00.

               IF loan.Currency <> iCurrency THEN DO:
                  /* величина основного долга по договору в валюте договора */
                  vPrincipalY = LnPrincipal(iContract,iContCode,vPrevOpDate,loan.Currency).

                  /* учетные курсы валюты договора и валюты результата */
                  ASSIGN
                     vLoanRateY = IF loan.Currency <> ""
                                  THEN FindRate("Учетный", loan.Currency, vPrevOpDate)
                                  ELSE 1

                     vCurRateY  = IF iCurrency <> ""
                                  THEN FindRate("Учетный", iCurrency, vPrevOpDate)
                                  ELSE 1
                     .

                  /* величина переоценки основного долга в валюте результата */
                  vReval = CurrRound(vPrincipalY * vLoanRateT / vCurRateT, iCurrency) -
                           CurrRound(vPrincipalY * vLoanRateY / vCurRateY, iCurrency).

                  IF vReval > 0 THEN vRevalDb = vReval.
               END.

               vSumDb = 0.

               FOR EACH loan-int WHERE
                        loan-int.contract  = iContract
                    AND loan-int.cont-code = loan.cont-code
                    AND loan-int.mdate     > vPrevOpDate
                    AND loan-int.mdate    <= b-op-date.op-date
                    AND loan-int.mdate    >= vbDate
                    AND loan-int.id-d = 0
                    AND NOT CAN-DO(vspar, STRING(loan-int.id-k)) /* 0,7,13 */
               NO-LOCK:
                  vSumDb = vSumDb + IF vLoanRateT = vCurRateT THEN loan-int.amt-rub ELSE
                           CurrRound(loan-int.amt-rub * vLoanRateT / vCurRateT, iCurrency).
               END.

            END.

            ASSIGN
               oRevalDb    = oRevalDb + vRevalDb
               oTurnoverDb = oTurnoverDb + vSumDb.

         END. /* FOR EACH b-loan*/

      END. /*FOR EACH b-op-date*/

  IF vByCalendDays THEN oCounter = vDaysNbr.

END PROCEDURE.

/*---------------------------------------------------------------------------
  Function   : LnAvgTurnoverDb
  Name       : Расчет среднего оборота по выдаче кредита и переоценке с начала
               месяца
  Purpose    : Расчет величины среднего оборота по предоставлению ссуды и
               переоценке с начала отчетного месяца в валюте результата iCurrency.
               Возвращает величину:
               - Средний оборот по выдаче ссуды и переоценке, в валюте
                 результата(vAvgTurnoverDb).
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnAvgTurnoverDb RETURNS DECIMAL (INPUT iContract AS CHAR,
                                          INPUT iContCode AS CHAR,
                                          INPUT iDate     AS DATE,
                                          INPUT iCurrency AS CHAR).

   DEFINE VARIABLE vTurnoverDb  AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vRevalDb     AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vCounter     AS INT64  NO-UNDO.

   DEFINE BUFFER b-loan FOR loan.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.

   RUN LnTurnoverDb ( iContract,
                      iContCode,
                      iDate,
                      iCurrency,
                      OUTPUT vTurnoverDb,
                      OUTPUT vRevalDb,
                      OUTPUT vCounter ).

   IF vCounter = 0 THEN
      RETURN 0.00.
   ELSE
      RETURN CurrRound((vTurnoverDb + vRevalDb) / vCounter, iCurrency).

END FUNCTION.

/*----------------------------------------------------------------------------
  Procedure  : LnORsrvCalcBase
  Name       : Расчет базы для определения минимальной величины формируемого
               резерва.
  Purpose    : Расчет базы для определения минимальной величины формируемого
               резерва.
               Возвращает величины:
                 oPP - определяется как большая из двух величин (в валюте результата):
                       1) рублевый эквивалент остатка счета на последний рабочий
                          день месяца;
                       2) среднедневной расчетный дебетовый оборот с учетом
                          дебетовых оборотов, обусловленных переоценкой.
                 oP = 50% * (oPP - C) + C в валюте результата, где
                      С - остаток ссудной задолженности;
                      Ф - фактически сформированный резерв на возможные потери по ссудам
                          под данную задолженность.
                 oIsBadDebt - признак безнадежной задолженности.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
               oPP         -
               oP          -
               oIsBadDebt  -
  Notes      :
  ----------------------------------------------------------------------------*/
PROCEDURE LnORsrvCalcBase.
   DEF INPUT  PARAM iContract    AS CHARACTER NO-UNDO.
   DEF INPUT  PARAM iContCode    AS CHARACTER NO-UNDO.
   DEF INPUT  PARAM iDate        AS DATE      NO-UNDO.
   DEF INPUT  PARAM iCurrency    AS CHARACTER NO-UNDO.
   DEF OUTPUT PARAM oPP          AS DECIMAL   NO-UNDO.
   DEF OUTPUT PARAM oP           AS DECIMAL   NO-UNDO.
   DEF OUTPUT PARAM oIsBadDebt   AS LOGICAL   NO-UNDO.

   DEFINE VARIABLE vPrincipal       AS DECIMAL  NO-UNDO. /*остаток задолженности по ссуде*/
   DEFINE VARIABLE vAvgTurnoverDb   AS DECIMAL  NO-UNDO. /*среднедневной оборот*/
   DEFINE VARIABLE vBadDebtCategory AS INT64 INIT ? NO-UNDO. /*категория качества для oP*/
   DEFINE VARIABLE vGrRiska         AS INT64 INIT ? NO-UNDO. /*категория качества ссуды*/

   DEF BUFFER comm-rate FOR comm-rate.

   vPrincipal       = LnPrincipal(iContract,iContCode,iDate,iCurrency).
   vAvgTurnoverDb   = LnAvgTurnoverDb(iContract,iContCode,iDate,iCurrency).
   oPP              = MAXIMUM(vPrincipal, vAvgTurnoverDb).
   oP               = CurrRound( 0.5 * (oPP - vPrincipal), iCurrency) + vPrincipal.

   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(iContCode, " ") = 2
              AND vPrincipal = 0
              AND vAvgTurnoverDb = 0) THEN
   DO:
   OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
   PUT STREAM out_s UNFORMATTED
      "Информация  Договор: " iContCode FORMAT "x(22)"
      ".  [Величина РР] = МАКСИМУМ( [Общая задолж.], [Средний дебетовый оборот])" SKIP
      "Информация  Договор: " iContCode FORMAT "x(22)"
      ".  " STRING(oPP, "->>>,>>>,>>>,>>9.99") " = "
      "МАКСИМУМ(" STRING(vPrincipal, "->>>,>>>,>>>,>>9.99") ", "
      STRING(vAvgTurnoverDb, "->>>,>>>,>>>,>>9.99") ")."
      SKIP
      "Информация  Договор: " iContCode FORMAT "x(22)"
      ".  [Величина Р] = 0.5 * ([Величина РР] - [Общая задолж.]) + [Общая задолж.]." SKIP
      "Информация  Договор: " iContCode FORMAT "x(22)"
      ".  " STRING(oP, "->>>,>>>,>>>,>>9.99") " = "
      "0.5 * (" STRING(oPP, "->>>,>>>,>>>,>>9.99") " - "
      STRING(vPrincipal, "->>>,>>>,>>>,>>9.99") ") + "
      STRING(vPrincipal, "->>>,>>>,>>>,>>9.99")
      SKIP.
   OUTPUT STREAM out_s CLOSE.
   END.

   /*является ли ссуда безнадежной:*/
   vBadDebtCategory = INT64(FGetSetting("ОфшорРез", "БезнадСсудаОфшор", "0")) NO-ERROR.
   IF vBadDebtCategory = ? THEN vBadDebtCategory = 0.

   /* Если настроечный параметр "БезнадСсудаОфшор" имеет значение 0, то
      любая ссуда считается обычной: oIsBadDebt = NO */

   IF vBadDebtCategory = 0 THEN oIsBadDebt = NO.
   ELSE DO:
      /*коэффициент резервирования ссуды */
      RUN GET_COMM_LOAN_BUF IN h_Loan (iContract,
                                       iContCode,
                                       "%Рез",
                                       iDate,
                                       BUFFER comm-rate).

      /*категория качества ссуды - группа риска*/
      IF AVAIL comm-rate THEN
         vGrRiska = LnGetGrRiska(comm-rate.rate-comm, iDate).

      IF (vGrRiska = 0) OR (vGrRiska = ?) THEN vGrRiska = 1.

      IF vGrRiska < vBadDebtCategory THEN oIsBadDebt = NO.
                                     ELSE oIsBadDebt = YES.
   END.

END PROCEDURE.

/*---------------------------------------------------------------------------
  Function   : LnORsrvRate
  Name       : Доля отчислений в резерв под операции с резидентом офшорной зоны.
  Purpose    : возвращает размер доли отчислений в резерв под ссуду,
               предоставленную резиденту офшорной зоны.

  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION LnORsrvRate RETURNS DECIMAL (
   INPUT iContract AS CHAR,
   INPUT iContCode AS CHAR,
   INPUT iDate     AS DATE
):
   DEFINE VARIABLE vRate    AS DECIMAL NO-UNDO.
   DEFINE VARIABLE vOfShore AS CHARACTER INIT ? NO-UNDO.
   DEFINE VARIABLE vOSGroup AS CHARACTER INIT ? NO-UNDO.
   DEFINE VARIABLE vPos     AS CHARACTER NO-UNDO. /* Код ПОСа. */

   DEFINE BUFFER b-loan FOR loan.
   DEFINE BUFFER b-code FOR code.

   RUN RE_B_LOAN IN h_Loan (iContract,iContCode,BUFFER b-loan).

   IF NOT AVAIL b-loan THEN
   DO:
      IF mIfPutPtot THEN
         loanNotFound (iContCode).
      RETURN ?.
   END.
                        /* Если ссуда входит в ПОС, то определяем ставку по ПОСу. */
   vPos = LnInBagOnDate (b-loan.contract, b-loan.cont-code, iDate).
   IF vPos NE ?
   THEN DO:
      FIND FIRST loan WHERE
               loan.contract  EQ "ПОС"
         AND   loan.cont-code EQ vPos
      NO-LOCK NO-ERROR.
      IF AVAIL loan
         THEN RETURN DEC (fGetBagRate ((BUFFER loan:handle), "%Рез", iDate, "rate-comm")).
   END.
   /* поиск хронологически последнего коэффициента резервирования по договору */
   vRate = GET_COMM ("%ОРез",
                     ?,
                     b-loan.currency,
                     iContract + "," + iContCode,
                     0.00,
                     0,
                     iDate).

   IF vRate <> ? THEN RETURN vRate.

   /* договор не типа "течение" -> смотрим вышестоящий договор */
   IF NUM-ENTRIES(iContCode, " ") = 2
   THEN
      RETURN LnORsrvRate(iContract,
                         ENTRY(1,iContCode, " "),
                         iDate).

   /* Если не задан индивидуальный коэффициент резервирования по договору,
      то используем ставку резервирования для офшорной зоны. */
   vOfShore = LnOffShoreCode(iContract,iContCode).

   IF (vOfShore <> ?) AND (vOfShore <> "") THEN DO:
     vOSGroup = ENTRY(1,vOfShore,".").

     FIND FIRST b-code WHERE
                b-code.class  = "ОфшорГр"
            AND b-code.parent = "ОфшорГр"
            AND b-code.code   = vOSGroup
     NO-LOCK NO-ERROR.

     IF AVAILABLE(b-code) THEN DO:
       vRate = DECIMAL(b-code.val) NO-ERROR.
       IF vRate >= 0 THEN RETURN vRate.
     END.
   END.

   RETURN 0.00.

END FUNCTION.


/*---------------------------------------------------------------------------
  Function   : LnRsrvOffShore
  Name       :
  Purpose    : Вспомогательная функция для LnFormRsrv и LnCalcRsrv.
               Корректирует значения формируемого и расчетного резерва для
               клиентов - резидентов оффшорных зон.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - код валюты
               iResult     - размер резерва
  Notes:
  ---------------------------------------------------------------------------*/
FUNCTION LnRsrvOffShore RETURNS DECIMAL (INPUT iContract AS CHAR,
                                         INPUT iContCode AS CHAR,
                                         INPUT iDate     AS DATE,
                                         INPUT iCurrency AS CHAR,
                                         INPUT iResult   AS DEC).

   DEFINE VARIABLE vORsrvRate AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE oPP        AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE oP         AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE vRes       AS DECIMAL  NO-UNDO.
   DEFINE VARIABLE oIsBadDebt AS LOGICAL  NO-UNDO.

   vRes = iResult.

   IF LnIsOffShoreOperation(iContract,iContCode) THEN
   DO:

      IF mIfPutPtot THEN
      DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " iContCode FORMAT "x(22)"
         ".  Операция с резидентом офшорной зоны. "
         SKIP.
      OUTPUT STREAM out_s CLOSE.

      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " iContCode FORMAT "x(22)"
         ".  Предварительно рассчитанная величина резерва: "
         STRING(iResult, "->>>,>>>,>>>,>>9.99")
         SKIP.
      OUTPUT STREAM out_s CLOSE.
      END.
      vORsrvRate = LnORsrvRate(iContract,iContCode,iDate).

      RUN LnORsrvCalcBase(iContract,
                          iContCode,
                          iDate,
                          iCurrency,
                          OUTPUT oPP,
                          OUTPUT oP,
                          OUTPUT oIsBadDebt).

      IF oIsBadDebt = YES THEN DO:

          vRes = MAX(iResult, CurrRound(iResult * (100 - vORsrvRate) / 100, iCurrency) +
                              CurrRound(oP * vORsrvRate / 100, iCurrency) ).

          IF mIfPutPtot THEN
          DO:
          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " iContCode FORMAT "x(22)"
             ".  Безнадежная задолженность. " SKIP
             "Информация  Договор: " iContCode FORMAT "x(22)"
             ".  [РезервКорр] = МАКСИМУМ( [РезервПредвар], "
             " [РезервПредвар] * (100 - [%ОРез])/100 + "
             " [Величина Р] * [%ОРез]/100 ) " SKIP
             "Информация  Договор: " iContCode FORMAT "x(22)"
             ".  " STRING(vRes, "->>>,>>>,>>>,>>9.99") " = "
             "МАКСИМУМ( " STRING(iResult, "->>>,>>>,>>>,>>9.99") " * "
             " (100 - " STRING(vORsrvRate, "->>9.999999") ") / 100, "
             "(" STRING(oP, "->>>,>>>,>>>,>>9.99") " * "
             STRING(vORsrvRate, "->>9.999999") " / 100)."
             SKIP.
          OUTPUT STREAM out_s CLOSE.

          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " iContCode FORMAT "x(22)"
             ".  Откорректированная          величина резерва: "
             STRING(vRes, "->>>,>>>,>>>,>>9.99")
             SKIP.
          OUTPUT STREAM out_s CLOSE.
          END.

          RETURN vRes.
      END.
      ELSE DO:

          vRes = MAX(iResult, CurrRound(oPP * vORsrvRate / 100, iCurrency) ).

          IF mIfPutPtot THEN
          DO:
          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " iContCode FORMAT "x(22)"
             ".  [РезервКорр] = МАКСИМУМ( [РезервПредвар], "
             "[Величина РР] * [%ОРез]/100 ) " SKIP
             "Информация  Договор: " iContCode FORMAT "x(22)"
             ".  " STRING(vRes, "->>>,>>>,>>>,>>9.99") " = "
             "МАКСИМУМ( " STRING(iResult, "->>>,>>>,>>>,>>9.99") ", "
             STRING(oPP, "->>>,>>>,>>>,>>9.99") " * "
             STRING(vORsrvRate, "->>9.999999") " / 100)."
             SKIP.
          OUTPUT STREAM out_s CLOSE.

          OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
          PUT STREAM out_s UNFORMATTED
             "Информация  Договор: " iContCode FORMAT "x(22)"
             ".  Откорректированная          величина резерва: "
             STRING(vRes, "->>>,>>>,>>>,>>9.99")
             SKIP.
          OUTPUT STREAM out_s CLOSE.
          END.

          RETURN vRes.
      END.
   END.

   RETURN iResult.

END FUNCTION.

/* Дата последнего изменения резерва, несвязанная  с изменением курса */

PROCEDURE GET_DATE_RES.
   DEF INPUT PARAM iContract AS CHAR     NO-UNDO.
   DEF INPUT PARAM iContCode AS CHAR     NO-UNDO.
   DEF INPUT PARAM iDate     AS DATE     NO-UNDO .
   DEF INPUT PARAM iIdInt    AS INT64  NO-UNDO.

   DEF OUTPUT PARAM oDate AS DATE INIT ? NO-UNDO .

   DEFINE VARIABLE vListIdInt AS CHARACTER   NO-UNDO INIT "46,88,350,351,356,357,354,355".
   DEFINE VARIABLE vListType  AS CHARACTER   NO-UNDO INIT "КредРез1,КредРезВб,КредРезП,КредРезПр,КредРезКом,КредРезПени,КредРезД,КредРезДПр".
   DEFINE VARIABLE vNomType   AS INT64     NO-UNDO.

   DEF BUFFER loan FOR loan .
   DEF BUFFER loan-int FOR loan-int .
   DEF BUFFER xloan-int FOR loan-int .

   RUN RE_B_LOAN IN h_Loan (iContract, iContCode, BUFFER loan).
   IF AVAIL loan THEN DO:
      vNomType = LOOKUP(STRING(iIdInt),vListIdInt).
      IF LnRsrvCheckType(iContract,
                         iContCode,
                         IF vNomType NE 0
                         THEN ENTRY(vNomType,vListType)
                         ELSE "КредРез"
                        )  /* Проверяем, должен ли по договору начисляться резерв */
      THEN DO:
         /* ищем движение по изменению резерва по срочной задолженности */
         FOR EACH loan-int OF LOAN WHERE loan-int.mdate LE iDate NO-LOCK BY loan-int.mdate
         DESCENDING :
            IF loan-int.id-d =  iIdInt
            OR loan-int.id-k =  iIdInt
            THEN DO :
               oDate = loan-int.mdate .
               LEAVE .
            END.
         END.
      END.
   END.
END PROCEDURE.

/**/
PROCEDURE GET_CR:

   DEF INPUT PARAMETER iCommission  AS CHAR  NO-UNDO.
   DEF INPUT PARAMETER iAcct        AS CHAR  NO-UNDO.
   DEF INPUT PARAMETER iCurrency    AS CHAR  NO-UNDO.
   DEF INPUT PARAMETER iKau         AS CHAR  NO-UNDO.
   DEF INPUT PARAMETER iMinVlaue    AS INT64   NO-UNDO.
   DEF INPUT PARAMETER iPeriod      AS INT64   NO-UNDO.
   DEF OUTPUT PARAMETER TABLE FOR tt-cr.

   DEF BUFFER comm-rate FOR comm-rate.


   EMPTY TEMP-TABLE tt-cr.
   FOR EACH comm-rate WHERE
            comm-rate.commission = "%рез" AND
            comm-rate.acct = "0" AND
            comm-rate.currency = iCurrency AND
            comm-rate.kau = iKau AND
            comm-rate.min-value = 0 AND
            comm-rate.period = 0 USE-INDEX kau NO-LOCK:

      CREATE tt-cr.
      ASSIGN
         tt-cr.recid-comm-rate = RECID(comm-rate)
         tt-cr.rate-comm = comm-rate.rate-comm
         tt-cr.since = comm-rate.since
      .

   END.

END PROCEDURE.

/*---------------------------------------------------------------------------
  Function   : Changes_GrRiska
  Name       : Изменение группы риска в текущем дне
  Purpose    : Определяет факт изменения в текущем дне группы риска
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  ---------------------------------------------------------------------------*/

FUNCTION Changes_GrRiska RETURNS CHAR (
                      INPUT iContract AS CHAR,
                      INPUT iContCode AS CHAR,
                      INPUT iDate     AS DATE
):

   DEFINE VARIABLE oResult        AS CHARACTER NO-UNDO INIT "0".
   DEFINE VARIABLE vGrToday       AS INT64   NO-UNDO.
   DEFINE VARIABLE vGrPast        AS INT64   NO-UNDO.
   DEFINE VARIABLE vGrParam       AS INT64   NO-UNDO.
   /* Находим актуальную группу риска */
   ASSIGN
      vGrParam   =   INT64(FGetSetting("Н302П","ГрПризДох", "?"))
      vGrToday   =   re_history_risk(iContract,iContCode,iDate,?)
      /* Находим группу риска за предыдущий день */
      vGrPast = re_history_risk(iContract,iContCode,iDate - 1,?)
   .
   /* Если в предыдущих днях нет записей о категории риска то возвращаем 0 */
   IF vGrPast NE ? THEN
   DO:
      IF vGrToday NE vGrPast
      THEN DO:
         IF     (vGrPast <= vGrParam)
            AND (vGrToday > vGrParam)
         THEN
            oResult = "2".
         ELSE IF (vGrPast > vGrParam) AND (vGrToday <= vGrParam)
         THEN
            oResult = "1".
      END.
   END.

   IF oResult EQ "0" THEN
      oResult = IF vGrToday > vGrParam
                THEN "3"
                ELSE "4".

   RETURN oResult.
END FUNCTION.
/*---------------------------------------------------------------------------
  Function   : GetChanges_GrRiska
  Name       : Изменение группы риска в текущем дне
  Purpose    : Определяет факт изменения в текущем дне группы риска
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  ---------------------------------------------------------------------------*/

FUNCTION GetChanges_GrRiska RETURNS CHAR (
                      INPUT iContract AS CHAR,
                      INPUT iContCode AS CHAR,
                      INPUT iDate     AS DATE
):

   DEFINE VARIABLE oResult        AS CHARACTER NO-UNDO INIT "0".
   oResult = Changes_GrRiska (iContract,iContCode,iDate).
   IF oResult > "2" THEN oResult = "0".

   RETURN oResult.
END FUNCTION.
/*---------------------------------------------------------------------------
  Function   : Get_NachBal
  Name       : Где начислять проценты
  Purpose    : Определяет где начислять проценты - на балансе или внебалансе
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  ---------------------------------------------------------------------------*/
FUNCTION Get_NachBal RETURNS CHAR (
                      INPUT iContract AS CHAR,
                      INPUT iContCode AS CHAR,
                      INPUT iDate     AS DATE
):

    DEFINE VARIABLE oResult      AS CHAR NO-UNDO.
    oResult = Changes_GrRiska (iContract,iContCode,iDate).
    CASE oResult:
       WHEN "1" THEN  oResult = "2".
       WHEN "2" THEN  oResult = "1".
       WHEN "3" THEN  oResult = "2".
       WHEN "4" THEN  oResult = "1".
    END CASE.

    RETURN oResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnCalcRsrvProc
  Name       : Расчет коэффициента резервирования
  Purpose    : Расчет коэффициента резервирования ( одинаковый для просроченных и начисленных процентов )
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
  ---------------------------------------------------------------------------*/
FUNCTION LnCalcRsrvProc RETURNS DEC (INPUT iContract  AS CHAR,
                                     INPUT iContCode  AS CHAR,
                                     INPUT iDate      AS DATE,
                                     INPUT iCurrency  AS CHAR):

   DEF VAR vParam     AS CHAR NO-UNDO INIT "21,46". /* Список параметров */
   &SCOPED-DEFINE   vParamNe0 "88" /* Если основной долг ведется не на 0 параметре.*/
   DEF VAR vI         AS INT64  NO-UNDO.
   DEF VAR vSm-Tot    AS DEC EXTENT 2 NO-UNDO.
   DEF VAR vSm-Db     AS DEC  NO-UNDO.
   DEF VAR vSm-Cr     AS DEC  NO-UNDO.
   DEF VAR vSh-Bal    AS DEC  NO-UNDO.
   DEF VAR vSm-TNC    AS DEC EXTENT 2 NO-UNDO. /* сумма на параметре в нац.валюте */
   DEF VAR vCurr      AS CHAR NO-UNDO. /* валюта, в которой учитывается параметр */
   DEF VAR vNpOkr     AS CHAR NO-UNDO. /* Значение НП ОкруглКР */
   DEF VAR vRetVal    AS DEC  NO-UNDO. /* Возвращаемое значение */
   DEF VAR vRate      AS DEC  NO-UNDO. /* Возвращаемое значение */
   DEF VAR vDoc-ref   AS CHAR NO-UNDO.
   DEF VAR vLnPrin    AS DEC  NO-UNDO.
   DEF VAR vLastDate  AS DATE NO-UNDO.
   DEF VAR vDateInt46 AS DATE NO-UNDO.
   DEF VAR vDateInt21 AS DATE NO-UNDO.
   DEF VAR vTmpSum    AS DEC  NO-UNDO.
   DEF VAR vSumParT   AS DEC  NO-UNDO.
   DEF VAR vCodOstpar AS INT  NO-UNDO.
   DEF VAR vResProcSt AS LOG  NO-UNDO.

   DEF BUFFER loan  FOR loan.
   DEF BUFFER bloan FOR loan. /* Локализация буфера. */
   
   FIND FIRST bloan WHERE bloan.contract  EQ iContract
                      AND bloan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
   IF AVAIL bloan 
   THEN DO:
      vSh-Bal = 0.
      vCodOstpar = INT64(GetParCode(bloan.class-code,'КодОснДолг')) NO-ERROR. 
      IF vCodOstpar NE 0 
      THEN
         vParam = {&vParamNe0}.
         /* Определяем, ведется ли резерв на этом договоре */
      IF LnRsrvCheckType(iContract, iContCode, "КредРезП") THEN
      DO:
         IF vCodOstpar EQ 0
         THEN
            vLnPrin = LnPrincipal (iContract, iContCode, iDate, iCurrency).
         ELSE DO:
            RUN STNDRT_PARAM_EX(bloan.contract,
                                bloan.cont-code,           /* Договор или транш */
                                vCodOstpar, /* Параметр */
                                iDate,                /* Дата */
                                bloan.since,
                                OUTPUT vLnPrin,           /* Сумма по параметру */
                                OUTPUT vSm-Db,
                                OUTPUT vSm-Cr).
            IF bloan.Currency <> iCurrency
            THEN 
               vLnPrin = CurToCurWork("Учетный",
                                      bloan.currency,
                                      iCurrency,
                                      iDate,
                                      vLnPrin).
         END.      
   
         vResProcSt = FGetSetting("РасчРезерв","РезПроцПоСтав","Нет") EQ "Да".  
         IF    vLnPrin NE 0 
            OR vResProcSt THEN
            vLastDate = iDate.
         ELSE
         DO:
            vLastDate = {&BQ-MIN-DATE}.
            /* Цикл по договору и его траншам для cont-type = "Течение" */
            FOR EACH loan WHERE
                    (loan.contract  EQ iContract
                 AND loan.cont-code EQ iContCode)             /* Сам договор */
               OR   (loan.contract  EQ iContract
                 AND loan.cont-code BEGINS(iContCode) + " ")  /* Его транши  */
            NO-LOCK:
   
               FIND LAST loan-int WHERE
                         loan-int.contract  EQ loan.contract
                     AND loan-int.cont-code EQ loan.cont-code
                     AND loan-int.id-d      EQ 21
                     AND loan-int.mdate     LE iDate
               NO-LOCK NO-ERROR.
   
               vDateInt21 = IF AVAIL loan-int THEN loan-int.mdate ELSE {&BQ-MIN-DATE}.
   
               FIND LAST loan-int WHERE
                         loan-int.contract  EQ loan.contract
                     AND loan-int.cont-code EQ loan.cont-code
                     AND loan-int.id-d      EQ 46
                     AND loan-int.mdate     LE iDate
               NO-LOCK NO-ERROR.
   
               vDateInt46 = IF AVAIL loan-int THEN loan-int.mdate ELSE {&BQ-MIN-DATE}.
   
               ASSIGN
                  vLastDate = MAX(vLastDate,vDateInt21,vDateInt46)
               .
            END.
            vLastDate = IF vLastDate NE ? THEN vLastDate - 1 ELSE iDate.
            IF vLastDate NE iDate 
            THEN DO:
            
               IF vCodOstpar EQ 0
               THEN
                  vLnPrin = LnPrincipal (iContract, iContCode, vLastDate, iCurrency).
               ELSE DO:
                  RUN STNDRT_PARAM_EX(iContract,
                                      iContCode,           /* Договор или транш */
                                      vCodOstpar,          /* Параметр */
                                      vLastDate,           /* Дата */
                                      bloan.since,
                                      OUTPUT vLnPrin,      /* Сумма по параметру */
                                      OUTPUT vSm-Db,
                                      OUTPUT vSm-Cr).
                  IF bloan.Currency NE iCurrency
                  THEN 
                     vLnPrin = CurToCurWork("Учетный",
                                            bloan.currency,
                                            iCurrency,
                                            vLastDate,
                                            vLnPrin).
               
               END.
            END.
         END.
   
         /* Цикл по договору и его траншам для cont-type = "Течение" */
         FOR EACH loan WHERE
                 (loan.contract  EQ iContract
              AND loan.cont-code EQ iContCode)             /* Сам договор */
            OR   (loan.contract  EQ iContract
              AND loan.cont-code BEGINS(iContCode) + " ")  /* Его транши  */
         NO-LOCK:
            ASSIGN
                vDoc-ref  = loan.doc-ref
                vSumParT = 0.
            
               /* Цикл по параметрам из списка vParam договора(транша) */
            DO vI = 1 TO NUM-ENTRIES(vParam):
               RUN STNDRT_PARAM_EX(iContract,
                                   loan.cont-code,         /* Договор или транш */
                                   INT64(ENTRY(vI, vParam)), /* Параметр */
                                   vLastDate,              /* Дата */
                                   loan.since,
                                   OUTPUT vSm-Tot[vI],         /* Сумма по параметру */
                                   OUTPUT vSm-Db,
                                   OUTPUT vSm-Cr).
                  /* Перевести сумму параметра в национальную валюту */
               RUN GetParP IN h_loan (RECID(loan),
                                      INT64(ENTRY(vI, vParam)),
                                      vSm-Tot[vI],
                                      OUTPUT vTmpSum,
                                      OUTPUT vCurr).
                  /* Если для расчета задана валюта отличная от национальной,
                  ** переведем сумму в заданную валюту */
               IF iCurrency NE vCurr THEN
                  vSm-TNC[vI] = CurToCurWork ("Учетный",
                                              vCurr,
                                              iCurrency,
                                              vLastDate,
                                              vSm-Tot[vI]).
               ELSE
                  vSm-TNC[vI] = vSm-Tot[vI].
                  /* Накапливается сумма по параметрам в валюте, заданной входным параметром 
                     вычитаем, т.к. в корректном договоре параметры из vParam 
                     имеют отрицательное значение => итог будет положительный для расчета % резерва */
               ASSIGN
                   vSh-Bal = vSh-Bal - vSm-TNC[vI]
                   vSumParT = vSumParT - vSm-TNC[vI]. /*это нужно только протокола*/
            END.
              /* Протоколирование, если НП "i254Stream" = Да */
            IF mIfPutPtot
              AND NOT(mIfPutNotNull
                      AND NUM-ENTRIES(vDoc-ref, " ") = 2
                      AND vSumParT = 0) THEN
            DO:
               OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
               PUT STREAM out_s UNFORMATTED
                  "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                  ".  Расчет к-та резерва с учетом обеспечения: "
               SKIP.
               DO vI = 1 TO NUM-ENTRIES(vParam):
                   PUT STREAM out_s UNFORMATTED
                     "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                     ".  Параметр: " ENTRY(vI, vParam)
                     ", остаток в валюте параметра: " TRIM(STRING(vSm-Tot[vI], "->>>>>>>>>>>>>>9.99"))
                     ", в валюте " iCurrency " сумма остатка: " TRIM(STRING(vSm-TNC[vI], "->>>>>>>>>>>>>>9.99"))
                  SKIP.
               END.
               OUTPUT STREAM out_s CLOSE.
            END.
         END.
      END.
      
         /* else не используется тк в ней не расчитывается vSh-Bal,
            здесь производился расчет только vLnPrin
         */
      vRate   = LnRsrvRate (iContract,
                            iContCode,
                            iDate).
      IF vLnPrin EQ 0 THEN
      DO:
         IF vResProcSt THEN
            vRetVal = vRate.
         ELSE
            vRetVal = 0.
      END.
      ELSE
         vRetVal = vSh-Bal / vLnPrin * 100. 
      IF ABS(vRate) LT ABS(vRetVal) THEN
         vRetVal = vRate.

      ASSIGN
         vNpOkr  = FGetSetting("ОкруглКр",?,"")
         vRetVal = IF vNpOkr EQ ""
                     THEN ROUND(vRetVal, 7)
                     ELSE ROUND(vRetVal, INT64(vNpOkr))
      .
   
      vDoc-ref  = bloan.doc-ref.
         /* Протоколирование, если НП "i254Stream" = Да */
      IF mIfPutPtot
         AND NOT(mIfPutNotNull
                 AND NUM-ENTRIES(vDoc-ref, " ") = 2
                 AND vRetVal = 0) THEN
      DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
            "Информация  Договор: " vDoc-ref FORMAT "X(22)"
            ".  Сформированный резерв по параметрам <" vParam ">: " 
            /* умножаем на -1, чтобы было, как в состоянии договора */
            TRIM(STRING(vSh-Bal * -1, "->>>>>>>>>>>>>>9.99")) SKIP
            "Информация  Договор: " vDoc-ref FORMAT "X(22)"
            ".  %Рез с учетом обеспечения: " TRIM(STRING(vRetVal, "->>>>>>9.99<<<"))
         SKIP.
         IF vNpOkr NE "" THEN
            PUT STREAM out_s UNFORMATTED
            "Округление %Рез до (знаков): " vNpOkr SKIP.
         OUTPUT STREAM out_s CLOSE.
      END.
   END.

   RETURN vRetVal.
END FUNCTION.

   /* ===================================================--=-=-= */
   /* Вспомогательная процедура для LnFormRsrvProc, LnFormRsrvVb */
   /* Возвращает сумму - расчетную базу резерва                  */
PROCEDURE LnFormRsrvProc_Sm:
   DEF INPUT  PARAM iContract    AS CHAR NO-UNDO.  /* Назначение договора */
   DEF INPUT  PARAM iContCode    AS CHAR NO-UNDO.  /* Номер договора */
   DEF INPUT  PARAM iDate        AS DATE NO-UNDO.  /* Дата операции */
   DEF INPUT  PARAM iAcctType    AS CHAR NO-UNDO.  /* Роль счета */
   DEF INPUT  PARAM iCurrency    AS CHAR NO-UNDO.  /* Валюта */
   DEF INPUT  PARAM iCheck       AS LOG  NO-UNDO.  /* Перед расчетом запускать LnRsrvCheckType для роли счета резерва */
   DEF OUTPUT PARAM oRsrvBase    AS DEC  NO-UNDO.  /* Расчетная база резерва */

   DEF VAR vI           AS INT64  NO-UNDO.
   DEF VAR vSm-Tot      AS DEC EXTENT 90 NO-UNDO. /* сумма на параметре */
   DEF VAR vSumm        AS DEC  NO-UNDO. /* сумма всех параметров */
   DEF VAR vSummInt     AS DEC  NO-UNDO. /* сумма параметров явл.процентами из loan.interest */
   DEF VAR vSm-TNC      AS DEC EXTENT 90 NO-UNDO. /* сумма на параметре в нац.валюте */
   DEF VAR vCurr        AS CHAR NO-UNDO. /* валюта, в которой учитывается параметр */
   DEF VAR CodOstpar    AS INT64  NO-UNDO.
   DEF VAR vDoc-ref     AS CHAR NO-UNDO.
   DEF VAR vParamP      AS CHAR NO-UNDO. /* Список суммируемых параметров */
   DEF VAR vParamM      AS CHAR NO-UNDO. /* Список вычитаемых параметров */
   DEF VAR vTypeRes     AS CHAR NO-UNDO. /* Роль счета резерва */
   DEF VAR vSumParT     AS DEC  NO-UNDO.

   DEF BUFFER loan FOR loan.
   DEF BUFFER code FOR code.

   main:
   DO:
      IF    iAcctType EQ ""
         OR iAcctType EQ ? THEN
         LEAVE main.

      IF NOT GetCodeBuff("РезервДог", iAcctType, BUFFER code) THEN
         LEAVE main.

      ASSIGN
         vParamP  = code.misc[1]
         vParamM  = code.misc[2]
         vTypeRes = code.name
      .

      IF vParamM NE "" THEN
      DO:
         {additem.i vParamP vParamM}
      END.

      IF     iCheck
         AND NOT LnRsrvCheckType (iContract,
                                  iContCode,
                                  vTypeRes) THEN
         LEAVE main.

         /* Определяется расчетная база как сумма параметров договора из iParam
         ** Если договор - течение (loan.cont-type EQ "Течение"), то определить
         ** и сложить сумму параметров и по всем его траншам. */
      FOR EACH loan WHERE
              (loan.contract  EQ iContract
           AND loan.cont-code EQ iContCode)             /* Сам договор */
         OR   (loan.contract  EQ iContract
           AND loan.cont-code BEGINS(iContCode) + " ")  /* Его транши  */
         NO-LOCK:
         ASSIGN
            vDoc-ref  = loan.doc-ref
            CodOstpar = GetParCode(loan.class-code,'КодОснДолг')
            vSumParT = 0
         .

         IF NUM-ENTRIES(vParamP) > 90 THEN DO:
             IF mIfPutPtot THEN
             DO:
               OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
               PUT STREAM out_s UNFORMATTED
                  "В классификаторе РезервДог для роли счета " iAcctType
                   "задано слишком много параметров (больше 90). Невозможно вычислить расчетную базу резерва."
               SKIP.
               OUTPUT STREAM out_s CLOSE.
             END.
             LEAVE main.
         END.
            /* Цикл по параметрам из списка iParam договора(транша) */
         DO vI = 1 TO NUM-ENTRIES(vParamP):
            RUN Get_Param_Cur IN h_loan (INT64(ENTRY(vI, vParamP)),   /* Параметр */
                                         CodOstpar,
                                         iContract,
                                         loan.cont-code,            /* Договор или транш */
                                         iDate,                     /* Дата */
                                         iCurrency,
                                         OUTPUT vCurr,
                                         OUTPUT vSm-Tot[vI],
                                         OUTPUT vSm-TNC[vI]).
               /* Накапливается сумма по параметрам в валюте, заданной входным параметром */
            vSm-TNC[vI] =  ABS(vSm-TNC[vI]).
            IF LOOKUP(ENTRY(vI, vParamP), vParamM) GT 0 THEN
                ASSIGN
                   vSumm    = vSumm - vSm-TNC[vI]
                   vSumParT = vSumParT - vSm-TNC[vI].
            ELSE
                ASSIGN
                   vSumm    = vSumm + vSm-TNC[vI]
                   vSumParT = vSumParT + vSm-TNC[vI].
         END.
         /* Протоколирование, если НП "i254Stream" = Да */
         IF mIfPutPtot
           AND NOT(mIfPutNotNull
                   AND NUM-ENTRIES(vDoc-ref, " ") = 2
                   AND vSumParT = 0) THEN
         DO:
           OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
           PUT STREAM out_s UNFORMATTED
              "Информация  Договор: " vDoc-ref FORMAT "X(22)"
              ".  Роль счета: " + iAcctType
           SKIP.
           DO vI = 1 TO NUM-ENTRIES(vParamP):
              PUT STREAM out_s UNFORMATTED
                  "Информация  Договор: " vDoc-ref FORMAT "X(22)"
                  ".  Параметр: " ENTRY(vI, vParamP)
                  ", остаток в валюте параметра: " TRIM(STRING(vSm-Tot[vI], "->>>>>>>>>>>>>>9.99"))
                  ", в валюте " iCurrency " сумма остатка: " TRIM(STRING(vSm-TNC[vI], "->>>>>>>>>>>>>>9.99"))
               SKIP.
           END.
           OUTPUT STREAM out_s CLOSE.
         END.
      END.
   END.  /* main */

   /* берем максимум, чтобы учесть переплату по %% (база расчета резерва не должна быть отрицательной) */
   oRsrvBase = MAX(0,vSumm).
END PROCEDURE.    /* LnFormRsrvProc_Sm */


/*---------------------------------------------------------------------------
  Procedure  : LnFormRsrvProc
  Name       : Расчета резерва для процентов.
  Purpose    : Расчета резерва для процентов.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iAcctType   - Роль счета
               iCurrency   - валюта
               iCheck      - перед расчетом запускать LnRsrvCheckType для роли счета резерва
               oRsrvProc   - коэффициента резервирования
               oRsrvRate   - резерва для процентов
  ---------------------------------------------------------------------------*/
PROCEDURE LnFormRsrvProc :

   DEF INPUT  PARAM iContract    AS CHAR NO-UNDO.
   DEF INPUT  PARAM iContCode    AS CHAR NO-UNDO.
   DEF INPUT  PARAM iDate        AS DATE NO-UNDO.
   DEF INPUT  PARAM iAcctType    AS CHAR NO-UNDO.  /* Роль счета */
   DEF INPUT  PARAM iCurrency    AS CHAR NO-UNDO.
   DEF INPUT  PARAM iCheck       AS LOG  NO-UNDO.  /* Перед расчетом запускать LnRsrvCheckType для роли счета резерва */
   DEF OUTPUT PARAM oRsrvProc    AS DEC  NO-UNDO.
   DEF OUTPUT PARAM oRsrvRate    AS DEC  NO-UNDO.

   DEF VAR vSumm        AS DEC  NO-UNDO.
   DEF VAR vDoc-ref     AS CHAR NO-UNDO.

   DEF BUFFER loan FOR loan.

      /* Получим базу для расчета резерва */
   RUN LnFormRsrvProc_Sm (iContract,
                          iContCode,
                          iDate,
                          iAcctType,
                          iCurrency,
                          iCheck,
                          OUTPUT vSumm).
   ASSIGN
      oRsrvProc = LnCalcRsrvProc (iContract ,iContCode ,iDate ,iCurrency)
      oRsrvRate = ROUND (oRsrvProc * vSumm / 100, 2)
   .

   FIND FIRST loan WHERE
              loan.contract  EQ iContract
      AND     loan.cont-code EQ iContCode
   NO-LOCK NO-ERROR.
   IF AVAIL loan THEN
      vDoc-ref = loan.doc-ref.

      /* Протоколирование, если НП "i254Stream" = Да */
   IF mIfPutPtot
       AND NOT(mIfPutNotNull
               AND NUM-ENTRIES(vDoc-ref, " ") = 2
               AND oRsrvRate = 0) THEN
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " vDoc-ref FORMAT "X(22)"
         ".  Расчетная база: " TRIM(STRING(vSumm,     "->>>>>>>>>>>>>>9.99")) SKIP
         "Информация  Договор: " vDoc-ref FORMAT "X(22)"
         ".  %Рез: "          TRIM(STRING(oRsrvProc, "->>>>>>>>9.99<<<")) SKIP
         "Информация  Договор: " vDoc-ref FORMAT "X(22)"
         ".  Сумма резерва: " TRIM(STRING(oRsrvRate, "->>>>>>>>>>>>>>9.99"))
      SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.

END PROCEDURE.    /* LnFormRsrvProc */


/*---------------------------------------------------------------------------
  Function   : LnFormRsrvVb
  Name       : Расчет резерва по условным обязательствам
  Parameters : iContract   - Назначение договора
               iContCode   - Номер договора
               iDate       - Дата операции
               iCurrency   - валюта
               iAcctType   - Список ролей счетов (через "|")
               iDeriv      - Признак заполнять ДР deriv на счете с указанной ролью.
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvVb RETURNS DEC (
   INPUT iContract AS CHAR,   /* Назначение договора */
   INPUT iContCode AS CHAR,   /* Номер договора */
   INPUT iDate     AS DATE,   /* На дату */
   INPUT iCurrency AS CHAR,   /* Валюта */
   INPUT iAcctType AS CHAR,   /* Список ролей счетов (через "|") */
   INPUT iDeriv    AS LOG,    /* Признак заполнять ДР deriv на счете с указанной ролью. */
   INPUT iScreen   AS LOG):   /* Выводить ли на экран протокол заполнения ДР deriv для 'ФормРезВб' */

   DEF VAR vAcctType AS CHAR NO-UNDO.  /* Роль счета */
   DEF VAR vRsrvProc AS DEC  NO-UNDO.  /* Коэффициент резервирования */
   DEF VAR vRsrvRate AS DEC  NO-UNDO.  /* Сумма резерва */
   DEF VAR vI        AS INT64  NO-UNDO.
   DEF VAR vSumm     AS DEC  NO-UNDO.  /* База для расчета резерва */
   DEF VAR vDoc-ref  AS CHAR NO-UNDO.
   DEF VAR vSumOb    AS DEC  NO-UNDO. /* Общая сумма обеспечения (КредВГар) */
   DEF VAR vAmtLoan  AS DEC  NO-UNDO. /* Часть суммы обеспечения по основному долгу (затычка) */
   DEF VAR vAmtAcct  AS DEC  NO-UNDO. /* Часть суммы обеспечения по условным обязательствам (КредЛин,КредН) */

   DEF BUFFER loan-acct FOR loan-acct.

   main:
   DO:
      IF NOT {assigned iAcctType} THEN
         LEAVE main.

         /* Протоколирование, если НП "i254Stream" = Да */
      IF mIfPutPtot THEN
      DO:
         OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
         PUT STREAM out_s UNFORMATTED
            "Информация  Договор: " ENTRY(1, iContract, "@") FORMAT "X(22)"
         SKIP.
         OUTPUT STREAM out_s CLOSE.
      END.

         /* Определим роль счета, по которому ведется учет резерва */
      blk:
      DO vI = 1 TO NUM-ENTRIES(iAcctType, ":"):
         FIND FIRST loan-acct WHERE
                    loan-acct.contract  EQ iContract
            AND     loan-acct.cont-code EQ iContCode
            AND     loan-acct.acct-type EQ ENTRY(vI, iAcctType, ":")
            AND     loan-acct.since     LE iDate
         NO-LOCK NO-ERROR.
         IF AVAIL loan-acct THEN
         DO:
            vAcctType = ENTRY(vI, iAcctType, ":").   /* Запоминаем роль счета и работаем только с ним */
            LEAVE blk.
         END.
      END.  /* blk */
         /* Если счет не удалось опередить - ругаемся в отчет и выходим */
      IF NOT {assigned vAcctType} THEN
      DO:
         IF mIfPutPtot THEN
         DO:
            OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
            PUT STREAM out_s UNFORMATTED
               "Не привязан ни один счет из списка ролей: <" + iAcctType + ">."
            SKIP.
            OUTPUT STREAM out_s CLOSE.
         END.
         LEAVE main.
      END.
         /* Получим базу для расчета резерва */
      RUN LnFormRsrvProc_Sm (iContract,
                             iContCode,
                             iDate,
                             vAcctType,
                             iCurrency,
                             NO,
                             OUTPUT vSumm).
	/********
         * Маслов Д. А.
	 * Исправляю ошибку округления.
         ********/
	vSumm = ROUND(vSumm,2).
         /* Корректируем расчетную базу резервирования с учетом обеспечения. */
      IF vAcctType EQ "КредВГар" THEN
            /* Для выданных гарантий (КредВГар) сумма обеспечения,
            вычисленная для учета в расчете резерва, берется в полном объеме. */
         ASSIGN
            vSumOb = LnCollateralValueAll (iContract,
                                           iContCode,
                                           iDate,
                                           ?,
                                           "",
                                           "all")
            vSumm = vSumm - vSumOb
         .
      ELSE IF CAN-DO("КредЛин,КредН", vAcctType) THEN
      DO:
            /* Для неиспользованных кредитных линий и лимитов (КредЛин, КредН)
            берется в части, выделенной для внебалансовых обязательств. */
         RUN LnCollateralValueEx (iContract,
                                  iContCode,
                                  iDate,
                                  ?,
                                  "",
                                  OUTPUT vAmtLoan,
                                  OUTPUT vAmtAcct).
         vSumm = vSumm - vAmtAcct.
      END.

      IF vSumm GT 0 THEN
      DO:
            /* определяем к-т резервирования */
         IF CAN-DO("КредВГар,КредНВГ,КредЛинВГ,КредЛин,КредН",
                   vAcctType) THEN
         DO:
            ASSIGN
               vRsrvProc = LnRsrvRateVb (iContract, iContCode, vAcctType, iDate)
               vRsrvRate = ROUND (vRsrvProc * vSumm / 100, 2)
            .
         END.
            /* Заполняем ДР deriv на счете с ролью vAcctType */
         IF iDeriv THEN
            RUN "setacdr1.p" (iContract,  /* Назначение договора */
                              iContCode,  /* Номер договора */
                              vAcctType,  /* Роль счета */
                              iDate,      /* На дату */
                              iScreen).   /* Выводить ли протокол на экран */


            /* Протоколирование, если НП "i254Stream" = Да */
         IF mIfPutPtot
             AND NOT(mIfPutNotNull
                     AND NUM-ENTRIES(iContCode, " ") = 2
                     AND vRsrvRate = 0) THEN
         DO:
            FIND FIRST loan WHERE
                       loan.contract  EQ iContract
               AND     loan.cont-code EQ iContCode
            NO-LOCK NO-ERROR.
            IF AVAIL loan THEN
               vDoc-ref = loan.doc-ref.
            OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
            PUT STREAM out_s UNFORMATTED
               "Информация  Договор: " vDoc-ref FORMAT "X(22)"
               ".  Расчетная база: " TRIM(STRING(vSumm,     "->>>>>>>>>>>>>>9.99")) SKIP
               "Информация  Договор: " vDoc-ref FORMAT "X(22)"
               ".  %Рез: "          TRIM(STRING(vRsrvProc, "->>>>>>>>>>>>>>9.99")) SKIP
               "Информация  Договор: " vDoc-ref FORMAT "X(22)"
               ".  Сумма резерва: " TRIM(STRING(vRsrvRate, "->>>>>>>>>>>>>>9.99"))
            SKIP.
            OUTPUT STREAM out_s CLOSE.
         END.
      END.
   END.  /* main */
   RETURN vRsrvRate.

END FUNCTION.    /* LnFormRsrvVb */


/*---------------------------------------------------------------------------
  Function   : LnFormRsrvProcGood
  Name       : Расчета резерва для процентов.
  Purpose    : Расчета резерва для процентов.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvProcGood RETURNS DEC (INPUT iContract  AS CHAR,
                                         INPUT iContCode  AS CHAR,
                                         INPUT iDate      AS DATE,
                                         INPUT iCurrency  AS CHAR):
   DEF VAR vRsrvProc  AS DEC  NO-UNDO.
   DEF VAR vRsrvRate  AS DEC  NO-UNDO.

      /* Протоколирование, если НП "i254Stream" = Да */
   IF mIfPutPtot
      AND NOT(mIfPutNotNull
              AND NUM-ENTRIES(iContCode, " ") = 2) THEN
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  Расчет резерва по срочным процентам за " STRING(iDate, "99/99/9999") + "."
      SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.

   RUN LnFormRsrvProc (iContract ,
                       iContCode ,
                       iDate ,
                       "КредТ" , /* Роль */
                       iCurrency,
                       TRUE,
                       OUTPUT vRsrvProc,
                       OUTPUT vRsrvRate).

   RETURN vRsrvRate.
END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvProcBad
  Name       : Расчет резерва для просроченных процентов.
  Purpose    : Расчет резерва для просроченных процентов.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iAcct       - счёт
               iCurrency   - валюта
  ---------------------------------------------------------------------------*/

FUNCTION LnFormRsrvProcBad RETURNS DEC (INPUT iContract  AS CHAR,
                                        INPUT iContCode  AS CHAR,
                                        INPUT iDate      AS DATE,
                                        INPUT iCurrency  AS CHAR):
   DEF VAR vRsrvProc  AS DEC  NO-UNDO.
   DEF VAR vRsrvRate  AS DEC  NO-UNDO.

      /* Протоколирование, если НП "i254Stream" = Да */
   IF mIfPutPtot
       AND NOT(mIfPutNotNull
               AND NUM-ENTRIES(iContCode, " ") = 2) THEN
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  Расчет резерва по просроченным процентам за " STRING(iDate, "99/99/9999") + "."
      SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.

   RUN LnFormRsrvProc (iContract ,
                       iContCode ,
                       iDate ,
                       "КредПр%", /* Список параметров для определения расчетной базы */
                       iCurrency,
                       TRUE,
                       OUTPUT vRsrvProc,
                       OUTPUT vRsrvRate).
   RETURN vRsrvRate.
END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvProcBadVb
  Name       : Расчет резерва для просроченных процентов на внебалансе.
  Purpose    : Расчет резерва для просроченных процентов на внебалансе.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iAcct       - счёт
               iCurrency   - валюта
  ---------------------------------------------------------------------------*/

FUNCTION LnFormRsrvProcBadVb RETURNS DEC (INPUT iContract  AS CHAR,
                                          INPUT iContCode  AS CHAR,
                                          INPUT iDate      AS DATE,
                                          INPUT iCurrency  AS CHAR):
   DEF VAR vRsrvProc  AS DEC  NO-UNDO.
   DEF VAR vRsrvRate  AS DEC  NO-UNDO.

      /* Протоколирование, если НП "i254Stream" = Да */
   IF mIfPutPtot
       AND NOT(mIfPutNotNull
               AND NUM-ENTRIES(iContCode, " ") = 2) THEN
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  Расчет резерва по просроченным процентам за " STRING(iDate, "99/99/9999") + "."
      SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.

   RUN LnFormRsrvProc (iContract ,
                       iContCode ,
                       iDate ,
                       "КредПр%B", /* Список параметров для определения расчетной базы */
                       iCurrency,
                       TRUE,
                       OUTPUT vRsrvProc,
                       OUTPUT vRsrvRate).
   RETURN vRsrvRate.
END FUNCTION.


/*****************************************************************************/
/*---------------------------------------------------------------------------
  Function   : LnFormRsrvDiskBad
  Name       : Расчет резерва для просроченного дисконта.
  Purpose    : Расчет резерва для просроченного дисконта.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvDiskBad RETURNS DEC (INPUT iContract AS CHAR,
                                        INPUT iContCode AS CHAR,
                                        INPUT iDate     AS DATE,
                                        INPUT iCurrency AS CHAR):
   DEF VAR vRsrvProc  AS DEC  NO-UNDO.
   DEF VAR vRsrvRate  AS DEC  NO-UNDO.

   RUN LnFormRsrvProc (iContract ,
                       iContCode ,
                       iDate ,
                       "КредДискПр" , /* Роль */
                       iCurrency,
                       FALSE,
                       OUTPUT vRsrvProc,
                       OUTPUT vRsrvRate).
   RETURN vRsrvRate.
END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvVProcGood
  Name       : Расчет резерва для УВ по процентам.
  Purpose    : Расчет резерва для учтенных векселей по процентам.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvVProcGood RETURNS DEC (INPUT iContract AS CHAR,
                                          INPUT iContCode AS CHAR,
                                          INPUT iDate     AS DATE,
                                          INPUT iCurrency AS CHAR):
   DEF VAR vRsrvProc AS DEC NO-UNDO.
   DEF VAR vRsrvRate AS DEC NO-UNDO.

   RUN LnFormRsrvProc (iContract ,
                       iContCode ,
                       iDate ,
                       "КредТ" ,
                       iCurrency,
                       FALSE,
                       OUTPUT vRsrvProc,
                       OUTPUT vRsrvRate).
   RETURN vRsrvRate.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvVProcBad
  Name       : Расчет резерва для УВ по просточенным процентам.
  Purpose    : Расчет резерва для учтенных векселей по просточенным процентам.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvVProcBad RETURNS DEC (INPUT iContract AS CHAR,
                                         INPUT iContCode AS CHAR,
                                         INPUT iDate     AS DATE,
                                         INPUT iCurrency AS CHAR):
   DEF VAR vRsrvProc AS DEC NO-UNDO.
   DEF VAR vRsrvRate AS DEC NO-UNDO.

   RUN LnFormRsrvProc (iContract ,
                       iContCode ,
                       iDate ,
                       "КредПр%" ,
                       iCurrency,
                       FALSE,
                       OUTPUT vRsrvProc,
                       OUTPUT vRsrvRate).
   RETURN vRsrvRate.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvVDiskGood
  Name       : Расчет резерва для УВ по дисконту.
  Purpose    : Расчет резерва для учтенных векселей по дисконту.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvVDiskGood RETURNS DEC (INPUT iContract AS CHAR,
                                          INPUT iContCode AS CHAR,
                                          INPUT iDate     AS DATE,
                                          INPUT iCurrency AS CHAR):
   DEF VAR vRsrvProc AS DEC NO-UNDO.
   DEF VAR vRsrvRate AS DEC NO-UNDO.

   RUN LnFormRsrvProc (iContract ,
                       iContCode ,
                       iDate ,
                       "КредДискДН" ,
                       iCurrency,
                       FALSE,
                       OUTPUT vRsrvProc,
                       OUTPUT vRsrvRate).
   RETURN vRsrvRate.

END FUNCTION.

/*---------------------------------------------------------------------------
  Procedure  : LnFormRsrvVek
  Name       : Расчет резерва учтенных векселей по начисленным процентам/дисконту.
  Purpose    : Расчет резерва учтенных векселей по начисленным процентам/дисконту
               с учетом категории качества.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iAcct       - счёт
               iCurrency   - валюта
               oRsrvProc   - коэффициент резервирования
               oRsrvRate   - расчитанный резерв
  ---------------------------------------------------------------------------*/
PROCEDURE LnFormRsrvVek:
   DEF INPUT  PARAMETER iContract AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iContCode AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iDate     AS DATE NO-UNDO.
   DEF INPUT  PARAMETER iAcct     AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iCurrency AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iCurrAcct AS CHAR NO-UNDO.
   DEF OUTPUT PARAMETER oRsrvProc AS DEC  NO-UNDO.
   DEF OUTPUT PARAMETER oRsrvRate AS DEC  NO-UNDO.

   DEF VAR vGrRisk AS INT64  NO-UNDO.  /* Группа риска договора */
   DEF VAR vGrPrD  AS INT64  NO-UNDO.  /* Группа риска НП "ГрПризДох" */
   DEF VAR vSumm   AS DEC  NO-UNDO.  /* Расчетная база */
   DEF VAR vAmnt   AS DEC  NO-UNDO.  /* Сумма в уменьшение расчетной базы */

      /* значение даты для расчета остатков по счетам берется из настроек фильтра
      ** ("> Ост. и обороты" -> "Остатки на:") по умолчанию = gend-date */
   RUN acct-pos IN h_base (iAcct,
                           iCurrAcct,
                           iDate,
                           iDate,
                           ?).
   ASSIGN
      oRsrvProc = LnCalcRsrvProc(iContract ,iContCode ,iDate ,iCurrency)
      vGrRisk   = re_history_risk(iContract, iContCode, iDate, 2)
      vGrPrD    = INT64(FGetSetting("Н302П", "ГрПризДох", "2"))
   .

      /* Если категория качества меньше или равна знач. НП "ГрПризДох", то
      ** расчетная база равна остатку на счете                             */
   IF iCurrency EQ "" THEN
      vSumm = sh-bal.
   ELSE
      IF iCurrAcct EQ "" THEN
         vSumm = CurToCurWork("Учетный",iCurrAcct,iCurrency,iDate,sh-bal).
      ELSE
         vSumm = CurToCurWork("Учетный",iCurrAcct,iCurrency,iDate,sh-val).
      /* Сумма в уменьшение расчетной базы */
   IF vGrRisk GT vGrPrD THEN DO:
      RUN rsrv-sm.p (iContract, iContCode, iDate, vGrPrD, OUTPUT vAmnt).
      IF iCurrency NE "" THEN
         vAmnt = CurToCurWork("Учетный","",iCurrency,iDate,vAmnt).
      vSumm = vSumm - vAmnt.
   END.

   oRsrvRate = ROUND (oRsrvProc * vSumm, 2).
      /* Протоколирование, если НП "i254Stream" = Да */
   IF mIfPutPtot THEN
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  Расчет резерва по вексельным процентам/дисконту за: " STRING(iDate, "99/99/9999")
         " Счет: " iAcct " остаток: " (IF iCurrency = "" THEN sh-bal ELSE sh-val) SKIP
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  Гр.риска по договору: " vGrRisk ", Гр.риска НП <ГрПризДох>: " vGrPrD SKIP
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  Сумма не признанного дохода: " TRIM(STRING(vAmnt, "->>>>>>>>>>>>>>9.99")) SKIP
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  Расчетная база: " TRIM(STRING(vSumm, "->>>>>>>>>>>>>>9.99")) SKIP
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  %Рез: " TRIM(STRING(oRsrvProc, "->>>>>>>>9.99<<<")) SKIP
         "Информация  Договор: " ENTRY(1, iContCode, "@") FORMAT "X(22)"
         ".  Сумма резерва: " TRIM(STRING(oRsrvRate, "->>>>>>>>>>>>>>9.99"))
      SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.
END PROCEDURE.


/*---------------------------------------------------------------------------
  Function   : LnFormRsrvCom
  Name       : Расчет резерва по комиссиям.
  Purpose    : Расчет резерва по комиссиям.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
               iType       - роль счета
  ---------------------------------------------------------------------------*/
FUNCTION LnFormRsrvCom RETURNS DECIMAL (INPUT iContract AS CHARACTER,
                                        INPUT iContCode AS CHARACTER,
                                        INPUT iDate     AS DATE,
                                        INPUT iCurrency AS CHARACTER,
                                        INPUT iType     AS CHARACTER):

   DEF VAR vRsrvProc  AS DEC  NO-UNDO.
   DEF VAR vRsrvRate  AS DEC  NO-UNDO.

   RUN LnFormRsrvProc (iContract,
                       iContCode,
                       iDate,
                       iType,
                       iCurrency,
                       TRUE,
                       OUTPUT vRsrvProc,
                       OUTPUT vRsrvRate).
   RETURN vRsrvRate.
END FUNCTION.


/*---------------------------------------------------------------------------
  Procedure  : LnCollateralValAcct
  Name       : Возвращает оценочную стоимость объекта обеспечения.
  Purpose    : Возвращает оценочную стоимость объекта обеспечения.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
               iAcct       - счет
               oSum        - ценочную стоимость объекта обеспечения.
  ---------------------------------------------------------------------------*/
PROCEDURE LnCollateralValAcct:
   DEF INPUT  PARAMETER iContract AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iContCode AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iDate     AS DATE NO-UNDO.
   DEF INPUT  PARAMETER iAcct     AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iCurrency AS CHAR NO-UNDO.
   DEF OUTPUT PARAMETER oSum      AS DEC  NO-UNDO.

   DEF BUFFER loan      FOR loan.      /* Локализация буфера. */
   DEF BUFFER loan-acct FOR loan-acct. /* Локализация буфера. */
   DEF BUFFER term-obl  FOR term-obl.  /* Локализация буфера. */

   DEF VAR vNomber            AS INT64    NO-UNDO.
   DEF VAR vSchet             AS INT64    NO-UNDO.
   DEF VAR vIndex             AS INT64    NO-UNDO.
   DEF VAR vLength            AS INT64    NO-UNDO.
   DEF VAR vAcctType          AS CHAR   NO-UNDO.
   DEF VAR vNN                AS INT64    NO-UNDO.
   DEF VAR vSurr              AS CHAR   NO-UNDO.
   DEF VAR vVidDogOb          AS CHAR   NO-UNDO. /* ДР ВидДогОб. */
   DEF VAR vNomerPP           AS INT64    NO-UNDO. /* ДР НомерПП. */
   DEF VAR vAmtLoan           AS DEC    NO-UNDO. /* Сумма по основному долгу. */
   DEF VAR vAmtAcct           AS DEC    NO-UNDO. /* Сумма по внебалансовым обязательствам. */
   DEF VAR vSumAll            AS DEC    NO-UNDO. /* Общая сумма обеспечения по договору. */
   DEF VAR vMarkModeV         AS CHAR   NO-UNDO. /* Способ оценки обеспечения. */
   DEF VAR vQualityCategory   AS CHAR   NO-UNDO. /* Категория качества. */
   DEF VAR vDecrRate          AS DEC    NO-UNDO. /* Коэф. снижения стоимости. */
   DEF VAR vRes               AS CHAR   NO-UNDO. /* Для вывода результата в лог */
   DEF VAR vIfPutPtotOld      AS LOG    NO-UNDO. /* Для хранения mIfPutPtot.*/

   ASSIGN
      vIfPutPtotOld  = mIfPutPtot
      mIfPutPtot     = NO
   .
   FIND FIRST loan WHERE loan.contract  EQ iContract
                     AND loan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
   IF AVAIL loan
   THEN DO:
      FIND LAST loan-acct WHERE loan-acct.contract   EQ loan.contract
                            AND loan-acct.cont-code  EQ loan.cont-code
                            AND loan-acct.acct       EQ iAcct
                            AND loan-acct.currency   EQ iCurrency
                            AND loan-acct.since      LE iDate
         NO-LOCK NO-ERROR.
      IF AVAIL loan-acct
      THEN DO:
         ASSIGN
            vLength = LENGTH(loan-acct.acct-type)
            vNomber = vLength + 1
         .

         DO vSchet = 0 TO vNomber - 1:
            INT64 (SUBSTRING(loan-acct.acct-type, vLength - vSchet , 1 ) ) NO-ERROR.
            IF ERROR-STATUS:ERROR THEN DO: 
               IF GetCode("ВидДогОб", SUBSTRING(loan-acct.acct-type,1, vLength - vSchet  ) ) NE ?  THEN
                  ASSIGN
                     vAcctType = SUBSTRING(loan-acct.acct-type,1, vLength - vSchet)
                     vNN       = INT64(SUBSTRING(loan-acct.acct-type, vLength - vSchet + 1,  vLength - (vLength - vSchet)))
                  NO-ERROR.
               LEAVE.
            END.
         END.

         IF vAcctType NE ""
         THEN DO:
            Block-term:
            FOR EACH term-obl WHERE (     term-obl.contract  EQ iContract
                                      AND term-obl.cont-code EQ iContCode
                                      AND term-obl.idnt      EQ 5
                                      AND term-obl.end-date  EQ ?
                                    )
                                    OR
                                    (     term-obl.contract  EQ iContract
                                      AND term-obl.cont-code EQ iContCode
                                      AND term-obl.idnt      EQ 5
                                      AND term-obl.end-date  GE iDate
                                    )
               NO-LOCK:
               ASSIGN
                  vSurr       = term-obl.contract         + ","
                              + term-obl.cont-code        + ","
                              + STRING(term-obl.idnt)     + ","
                              + STRING(term-obl.end-date) + ","
                              + STRING(term-obl.nn)
                  vVidDogOb   =     GetXAttrValue ("term-obl",vSurr,"ВидДогОб")
                  vNomerPP    = INT64(GetXAttrValue ("term-obl",vSurr,"НомерПП"))
               .
               IF      vVidDogOb EQ vAcctType
                  AND  vNomerPP  EQ vNN
               THEN LEAVE Block-term.

            END.
            IF AVAIL term-obl
            THEN DO:
               RUN LnCollateralValueEx (loan.contract,
                                        loan.cont-code,
                                        iDate,
                                        ?,
                                        iCurrency,
                                        OUTPUT vAmtLoan,
                                        OUTPUT vAmtAcct).
               ASSIGN
                  oSum              = LnPledgeQuality (term-obl.contract,
                                                       term-obl.cont-code,
                                                       term-obl.idnt,
                                                       term-obl.end-date,
                                                       term-obl.nn,
                                                       iDate,
                                                       iCurrency)
                  vSumAll           = LnCollateralValueAll (loan.contract,
                                                            loan.cont-code,
                                                            iDate,
                                                            ?,
                                                            iCurrency,
                                                            "all")
                  oSum              = IF vSumAll NE 0 THEN oSum * vAmtLoan / vSumAll ELSE 0
                  vMarkModeV        = GetCodeName("ОценкаОбесп",
                                            STRING(term-obl.fop-offbal + 1))
                  vQualityCategory  = Get_QualityGar ("comm-rate",
                                      vSurr,
                                      iDate)
                  vQualityCategory  = IF    vQualityCategory EQ ?
                                         OR vQualityCategory EQ "?"
                                      THEN ""
                                      ELSE vQualityCategory
                  vDecrRate         = GET_COMM("Обесп",
                                              ?,
                                              term-obl.currency,
                                              vSurr,
                                              0.00,
                                              0,
                                              iDate)
                  vDecrRate         = IF vDecrRate EQ ?
                                      THEN 100
                                      ELSE vDecrRate
                  vRes              = "Стоимость объектов обеспечения:                     " + (IF oSum EQ ? THEN "?" ELSE STRING(oSum)) + "~n"
                                    + "Сумма договора обеспечения:                         " + STRING(term-obl.amt-rub)                  + "~n"
                                    + "Валюта:                                             '" + iCurrency + "'"                           + "~n"
                                    + "Способ оценки объекта обеспечения:                  " + vMarkModeV                                + "~n"
                                    + "Категория качества обеспечения:                     " + vQualityCategory                          + "~n"
                                    + "Коэффициент снижения стоимости:                     " + STRING(vDecrRate)                         + "~n"
                                    + "Часть суммы обеспечения по основному долгу:         " + STRING(vAmtLoan)                          + "~n"
                                    + "Часть суммы обеспечения по условным обязательствам: " + STRING(vAmtAcct)
               .
            END.
            ELSE
               vRes =   "Не найдено обеспечение для договора "      +
                        "с назначением '"           + iContract     +
                        "' и номером '"             + iContCode     +
                        "' действующее на '"        + STRING(iDate) +
                        "'." .
         END.
      END.
      ELSE
         vRes =   "Счет '"                                     + iAcct         +
                  "' в валюте '"                               + iCurrency     +
                  "' не привязан к договору с назначением '"   + iContract     +
                  "' с номером '"                              + iContCode     +
                  "' до '"                                     + STRING(iDate,"99/99/9999") +
                  "'." .
   END.
   ELSE
      vRes = "Не найден договор с назначением '" + iContract     +
             "' и номером '"                     + iContCode     + "'.".
   mIfPutPtot = vIfPutPtotOld.
   IF mIfPutPtot
   THEN DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED vRes SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.
   RETURN.
END PROCEDURE.

/* Инструмент, возвращающий оценочную стоимость объекта обеспечения,
** без учета понижающего коэффициента.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
               iAcct       - счет
               oSum        - ценочную стоимость объекта обеспечения. */
PROCEDURE LnPledgeAcct.
   DEF INPUT  PARAMETER iContract AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iContCode AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iDate     AS DATE NO-UNDO.
   DEF INPUT  PARAMETER iAcct     AS CHAR NO-UNDO.
   DEF INPUT  PARAMETER iCurrency AS CHAR NO-UNDO.
   DEF OUTPUT PARAMETER oSum      AS DEC  NO-UNDO.

   DEF BUFFER loan      FOR loan.      /* Локализация буфера. */
   DEF BUFFER loan-acct FOR loan-acct. /* Локализация буфера. */
   DEF BUFFER term-obl  FOR term-obl.  /* Локализация буфера. */

   DEF VAR vNomber            AS INT64    NO-UNDO.
   DEF VAR vSchet             AS INT64    NO-UNDO.
   DEF VAR vIndex             AS INT64    NO-UNDO.
   DEF VAR vLength            AS INT64    NO-UNDO.
   DEF VAR vAcctType          AS CHAR   NO-UNDO.
   DEF VAR vNN                AS INT64    NO-UNDO.
   DEF VAR vSurr              AS CHAR   NO-UNDO.
   DEF VAR vVidDogOb          AS CHAR   NO-UNDO. /* ДР ВидДогОб. */
   DEF VAR vNomerPP           AS INT64    NO-UNDO. /* ДР НомерПП. */
   DEF VAR vRes               AS CHAR   NO-UNDO. /* Для вывода результата в лог */
   DEF VAR vIfPutPtotOld      AS LOG    NO-UNDO. /* Для хранения mIfPutPtot.*/

   ASSIGN
      vIfPutPtotOld  = mIfPutPtot
      mIfPutPtot     = NO
   .
   FIND FIRST loan WHERE loan.contract  EQ iContract
                     AND loan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
   IF AVAIL loan
   THEN DO:
      FIND LAST loan-acct WHERE loan-acct.contract   EQ loan.contract
                            AND loan-acct.cont-code  EQ loan.cont-code
                            AND loan-acct.acct       EQ iAcct
                            AND loan-acct.currency   EQ iCurrency
                            AND loan-acct.since      LE iDate
         NO-LOCK NO-ERROR.
      IF AVAIL loan-acct
      THEN DO:
         ASSIGN
            vLength = LENGTH(loan-acct.acct-type)
            vNomber = vLength + 1
         .

         DO vSchet = 0 TO vNomber - 1:
            INT64 (SUBSTRING(loan-acct.acct-type, vLength - vSchet , 1 ) ) NO-ERROR.
            IF ERROR-STATUS:ERROR THEN DO: 
               IF GetCode("ВидДогОб", SUBSTRING(loan-acct.acct-type,1, vLength - vSchet  ) ) NE ?  THEN
                  ASSIGN
                     vAcctType = SUBSTRING(loan-acct.acct-type,1, vLength - vSchet)
                     vNN       = INT64(SUBSTRING(loan-acct.acct-type, vLength - vSchet + 1,  vLength - (vLength - vSchet)))
                  NO-ERROR.
               LEAVE.
            END.
         END.

         IF vAcctType NE ""
         THEN DO:
            Block-term:
            FOR EACH term-obl WHERE (     term-obl.contract  EQ iContract
                                      AND term-obl.cont-code EQ iContCode
                                      AND term-obl.idnt      EQ 5
                                      AND term-obl.end-date  EQ ?
                                    )
                                    OR
                                    (     term-obl.contract  EQ iContract
                                      AND term-obl.cont-code EQ iContCode
                                      AND term-obl.idnt      EQ 5
                                      AND term-obl.end-date  GE iDate
                                    )
               NO-LOCK:
               ASSIGN
                  vSurr       = term-obl.contract         + ","
                              + term-obl.cont-code        + ","
                              + STRING(term-obl.idnt)     + ","
                              + STRING(term-obl.end-date) + ","
                              + STRING(term-obl.nn)
                  vVidDogOb   =     GetXAttrValue ("term-obl",vSurr,"ВидДогОб")
                  vNomerPP    = INT64(GetXAttrValue ("term-obl",vSurr,"НомерПП"))
               .
               IF      vVidDogOb EQ vAcctType
                  AND  vNomerPP  EQ vNN
               THEN LEAVE Block-term.

            END.
            IF AVAIL term-obl
            THEN
               ASSIGN
                  oSum = LnPledge(term-obl.contract,
                                  term-obl.cont-code,
                                  term-obl.idnt,
                                  term-obl.end-date,
                                  term-obl.nn,
                                  iDate,
                                  ?,
                                  iCurrency)
               .
            ELSE
               vRes =   "Не найдено обеспечение для договора "      +
                        "с назначением '"           + iContract     +
                        "' и номером '"             + iContCode     +
                        "' действующее на '"        + STRING(iDate) +
                        "'." .
         END.
      END.
      ELSE
         vRes =   "Счет '"                                     + iAcct         +
                  "' в валюте '"                               + iCurrency     +
                  "' не привязан к договору с назначением '"   + iContract     +
                  "' с номером '"                              + iContCode     +
                  "' до '"                                     + STRING(iDate,"99/99/9999") +
                  "'." .
   END.
   ELSE
      vRes = "Не найден договор с назначением '" + iContract     +
             "' и номером '"                     + iContCode     + "'.".
   mIfPutPtot = vIfPutPtotOld.
   IF mIfPutPtot
   THEN DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED vRes SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.
   RETURN.
END PROCEDURE.

/* Определение группы риска по договору с учетом вхождения в ПОС */
PROCEDURE LnGetGrRiskUchBag.

   DEF INPUT  PARAM iContract AS CHAR NO-UNDO. /* Назаначение договора */
   DEF INPUT  PARAM iContcode AS CHAR NO-UNDO. /* Номер договора */
   DEF INPUT  PARAM iRes      AS DEC  NO-UNDO. /* Ставка резервирования */
   DEF INPUT  PARAM iDate     AS DATE NO-UNDO. /* Дата */
   DEF OUTPUT PARAM oGrRsrv   AS INT64  NO-UNDO. /* Группа риска */

   DEF VAR vIsOnPos AS CHAR NO-UNDO. /* Код протфеля, если договор привязан к портфелю */

   DEF BUFFER loan FOR loan. /* Локализация буффера. */

   mb:
   DO ON ERROR UNDO, LEAVE:
      /* Находим договор */
      FIND FIRST loan WHERE loan.contract  EQ iContract
                        AND loan.cont-code EQ iContcode
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN
         LEAVE mb.

      /* Определяем - находится ли он на переданную дату в ПОС'е */
      vIsOnPos = LnInBagOnDate (iContract, iContcode, iDate).

      /* Теперь в зависимости от того в ПОС'е ссуда или нет определяем группу риска */
      IF vIsOnPos EQ ? THEN
         oGrRsrv = LnGetGrRiska (iRes,iDate).
      ELSE
         oGrRsrv = PsGetGrRiska (iRes,loan.cust-cat,iDate).
   END.
END PROCEDURE.

FUNCTION GetLoanGrRisk RETURNS LOG (INPUT  iContract  AS CHAR,   /* Назаначение договора */
                                    INPUT  iContCode  AS CHAR,   /* Номер договора */
                                    INPUT  iDate      AS DATE,   /* Дата */
                                    OUTPUT oRate      AS DEC,    /* Ставка */
                                    OUTPUT oGrRisk    AS INT64): /* Группа риска */

   DEF BUFFER comm-rate FOR comm-rate. /* Локализация буфера. */

   DEFINE VARIABLE vOk AS LOGICAL     NO-UNDO.

   RUN GET_COMM_LOAN_BUF in h_Loan (iContract,
                                    iContCode,
                                    "%Рез",
                                    iDate,
                                    BUFFER comm-rate).
   IF AVAIL comm-rate 
   THEN DO:
      oRate   = comm-rate.rate-comm.
      oGrRisk = INT64 (GetXAttrValueEx("comm-rate",
                                       STRING(comm-rate.comm-rate-id),
                                       "КатегорияКач",
                                       ?)).
      IF oGrRisk EQ ? 
      THEN
          RUN LnGetRiskGrOnDate (       oRate,
                                        iDate,
                                 OUTPUT oGrRisk).
      vOk = TRUE.
   END.
   RETURN vOk.
END FUNCTION.

PROCEDURE GetRateGrRisk:
   DEF INPUT  PARAM iContract AS CHAR NO-UNDO. /* Назаначение договора */
   DEF INPUT  PARAM iContcode AS CHAR NO-UNDO. /* Номер договора */
   DEF INPUT  PARAM iDate     AS DATE NO-UNDO. /* Дата */
   DEF OUTPUT PARAM oRate     AS DEC  NO-UNDO. /* Ставка */
   DEF OUTPUT PARAM oGrRisk   AS INT64  NO-UNDO. /* Группа риска */

   DEF BUFFER comm-rate FOR comm-rate. /* Локализация буфера. */
   DEF BUFFER loan      FOR loan.      /* Локализация буфера. */
   DEFINE VARIABLE vPos AS CHARACTER   NO-UNDO.
   vPos = LnInBagOnDate (iContract, iContCode, iDate).
   IF vPos NE ?
   THEN DO:
      FIND FIRST loan WHERE loan.contract  EQ "ПОС"
                        AND loan.cont-code EQ vPos
         NO-LOCK NO-ERROR.
      IF AVAIL loan
      THEN DO:
         oRate   = DEC (fGetBagRate ((BUFFER loan:handle), "%Рез", iDate, "rate-comm")).
         oGrRisk = PsGetGrRiska   (oRate, loan.cust-cat, iDate).
      END.
   END.
   ELSE DO: 
       
      IF     NOT GetLoanGrRisk (iContract,
                                iContcode,
                                iDate,    
                                OUTPUT oRate,    
                                OUTPUT oGrRisk)  
         AND NOT CAN-FIND(loan WHERE loan.contract  EQ iContract
                                  AND loan.cont-code EQ iContCode
                                  AND loan.cont-type EQ "Течение" )
                                  AND NUM-ENTRIES(iContCode, " ") = 2
      THEN 
         RUN GetRateGrRisk(iContract,
                             ENTRY(1,iContCode," "),
                             iDate,
                             OUTPUT oRate, 
                             OUTPUT oGrRisk).
   END.
   IF oGrRisk EQ ?
   THEN
      oGrRisk = 1.
END PROCEDURE.

/*---------------------------------------------------------------------------
  Function   : LnFormRsrvDam
  Name       : Разработать инструмент для расчета резерва по требованиям по возмещению убытка.
  Purpose    : Разработать инструмент для расчета резерва по требованиям по возмещению убытка.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта
---------------------------------------------------------------------------*/

FUNCTION LnFormRsrvDam RETURNS DEC (INPUT iContract  AS CHAR,
                                    INPUT iContCode  AS CHAR,
                                    INPUT iDate      AS DATE,
                                    INPUT iCurrency  AS CHAR):


   DEFINE BUFFER loan FOR loan. /* Локализация буфера. */

   DEFINE VARIABLE vSumm     AS DECIMAL     NO-UNDO.
   DEFINE VARIABLE vRsrvRate AS DECIMAL     NO-UNDO.
   DEFINE VARIABLE vResult   AS DECIMAL     NO-UNDO.

   FIND FIRST loan WHERE loan.contract  EQ iContract
                     AND loan.cont-code EQ iContcode
      NO-LOCK NO-ERROR.
   IF AVAIL loan
   THEN DO:
      RUN LnFormRsrvProc_Sm
                          (loan.contract,
                           loan.cont-code,
                           iDate,
                           "КредВозмУб",
                           iCurrency,
                           FALSE,
                           OUTPUT vSumm).
      vRsrvRate = LnRsrvRate (loan.contract,
                              loan.cont-code,
                              iDate).
      vResult = ROUND (vSumm * vRsrvRate / 100,  2).
   END.
   IF mIfPutPtot
      AND NOT(mIfPutNotNull
               AND NUM-ENTRIES(loan.doc-ref, " ") = 2
               AND vResult = 0)
   THEN DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация: Договор:  "  loan.doc-ref  FORMAT "X(22)"
         ".  Расчетная база:                         " TRIM(STRING(vSumm,     "->>>>>>>>>>>>>>9.99")) SKIP
         "Информация: Договор:  "  loan.doc-ref  FORMAT "X(22)"
         ".  %Рез:                                   " TRIM(STRING(vRsrvRate, "->>>>>>>>>>>>>>9.99")) SKIP
         "Информация: Договор:  "  loan.doc-ref  FORMAT "X(22)"
         ".  Сумма резерва по треб. по возм. убытка: " TRIM(STRING(vResult,   "->>>>>>>>>>>>>>9.99")) SKIP
         .
      OUTPUT STREAM out_s CLOSE.
   END.

   RETURN vResult.

END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnWithGuarantee
  Name       : Есть ли у ссуды обеспечение
  Purpose    : Определяет есть ли у ссуды обеспечения с действительной стоимостью > 0
               Возвращает логическое значение.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnWithGuarantee RETURNS LOGICAL (INPUT iContract AS CHAR,
                                          INPUT iContCode AS CHAR,
                                          INPUT iDate     AS DATE):
   DEF VAR vGurAmt AS DEC NO-UNDO.
   
   /* получаем справедливую стоимость обеспечения по всему договору (соглашение + транши) */
   vGurAmt = LnCollateralValueAll(iContract,iContCode,iDate,iDate,"","all").
    
   IF mIfPutPtot THEN 
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация: Договор:  "  ENTRY(1,iContCode,"@")  FORMAT "X(22)" 
         ". Наличие обеспечения: " (IF vGurAmt GT 0 THEN "Да" ELSE "Нет") SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.
      
   IF vGurAmt GT 0 THEN
      RETURN TRUE.
   ELSE 
      RETURN FALSE.                                          
END FUNCTION.

/*---------------------------------------------------------------------------
  Function   : LnInitPayPerGuar
  Name       : Возвращает величину процента, которую составляет первоначальный взнос от справедливой суммы обеспечения
  Purpose    : Возвращает величину процента, которую составляет первоначальный взнос от справедливой суммы обеспечения
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта результата
---------------------------------------------------------------------------*/
FUNCTION LnInitPayPerGuar RETURNS DEC (INPUT iContract AS CHAR,
                                       INPUT iContCode AS CHAR,
                                       INPUT iDate     AS DATE,
                                       INPUT iCurrency AS CHAR):
   DEF VAR vInitPay AS DEC NO-UNDO.
   DEF VAR vGurAmt  AS DEC NO-UNDO.
   DEF VAR vProc    AS DEC NO-UNDO. 
   
   /* Получаем сумму первоначального взноса */
   vInitPay = DEC(GetXAttrValueEx("loan",
                                  STRING(iContract)    + "," +
                                  STRING(iContCode),
                                  "InitPay",
                                  "0")
                  ).
   /* Получаем справидливую стоимость обеспечения на переданную дату (соглашение + транши) */
   vGurAmt = LnCollateralValueAll(iContract,iContCode,iDate,iDate,iCurrency,"all").
   
   /* Вычисляем часть первоначального взноса от обеспечения в процентах */
   vProc = vInitPay * 100 / vGurAmt.  
   
   IF mIfPutPtot THEN 
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация: Договор:  "  ENTRY(1,iContCode,"@")  FORMAT "X(22)" 
         ". Соотношение первоначального взноса к текущей справедливой стоимости обеспечения в процентах " 
         STRING(vProc,">>>,>>>,>>9.99") SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.
    
   RETURN vProc.
END FUNCTION.
                                       
/*---------------------------------------------------------------------------
  Function   : LnMainDebtPerGuar
  Name       : Возвращает величину процента, которую составляет остаток основного долга от справедливой суммы обеспечения
  Purpose    : Возвращает величину процента, которую составляет остаток основного долга от справедливой суммы обеспечения
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
               iCurrency   - валюта результата
---------------------------------------------------------------------------*/
FUNCTION LnMainDebtPerGuar RETURNS DEC (INPUT iContract AS CHAR,
                                        INPUT iContCode AS CHAR,
                                        INPUT iDate     AS DATE,
                                        INPUT iCurrency AS CHAR):
   DEF VAR vDebt    AS DEC NO-UNDO.
   DEF VAR vGurAmt  AS DEC NO-UNDO.
   DEF VAR vProc    AS DEC NO-UNDO. 
   
   /* Получаем сумму остатка по основному долгу на переданную дату */
   vDebt = LnPrincipal(iContract,iContCode,iDate,iCurrency).
   /* Получаем справидливую стоимость обеспечения на переданную дату (соглашение + транши) */
   vGurAmt = LnCollateralValueAll(iContract,iContCode,iDate,iDate,iCurrency,"all").
   
   /* Вычисляем часть первоначального взноса от обеспечения в процентах */
   vProc = vDebt * 100 / vGurAmt.  
   
   IF mIfPutPtot THEN 
   DO:
      OUTPUT STREAM out_s TO "loanrsrv.log" APPEND.
      PUT STREAM out_s UNFORMATTED
         "Информация: Договор:  "  ENTRY(1,iContCode,"@")  FORMAT "X(22)" 
         ". Соотношение величины основного долга к текущей справедливой стоимости обеспечения в процентах " 
         STRING(vProc,">>>,>>>,>>9.99") SKIP.
      OUTPUT STREAM out_s CLOSE.
   END.
    
   RETURN vProc.
END FUNCTION.

PROCEDURE setVerifyRelType :
DEFINE INPUT PARAMETER iRel_Type AS LOGICAL NO-UNDO .
   ASSIGN
      mVerRel_Type = iRel_Type
      .
END PROCEDURE. /* setVerifyRelType */


PROCEDURE GetVerifyRelType :
DEFINE OUTPUT PARAMETER iRel_Type AS LOGICAL NO-UNDO .
    ASSIGN
      iRel_Type = mVerRel_Type
    .
END PROCEDURE. /* GetVerifyRelType */

PROCEDURE SetSpisBaseParam :
DEFINE INPUT PARAMETER iSpisBaseParam AS CHARACTER NO-UNDO .
DEFINE INPUT PARAMETER iSpisBaseParamP AS CHARACTER NO-UNDO .
   ASSIGN
      mSpisBaseParam = iSpisBaseParam
      mSpisBaseParamP = iSpisBaseParamP
      .
END PROCEDURE. /* setSpisBaseParam */


PROCEDURE GetSpisBaseParam :
DEFINE OUTPUT PARAMETER iSpisBaseParam AS CHARACTER NO-UNDO .
DEFINE OUTPUT PARAMETER iSpisBaseParamP AS CHARACTER NO-UNDO .
    ASSIGN
      iSpisBaseParam  = IF mSpisBaseParam  = ?  THEN "" ELSE mSpisBaseParam
      iSpisBaseParamP = IF mSpisBaseParamP = ? THEN "" ELSE mSpisBaseParamP
    .
END PROCEDURE. /* GetSpisBaseParam */

/*---------------------------------------------------------------------------
  Function   : LnGetExtraditionSum
  Name       : Возвращает сумму выданного кредита.
  Purpose    : Возвращает сумму выданного кредита.
  Parameters : iContract   - назначение договора
               iContCode   - номер договора
               iDate       - дата операции
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnGetExtraditionSum RETURNS DECIMAL (INPUT iContract AS CHAR,
                                              INPUT iContCode AS CHAR,
                                              INPUT iDate     AS DATE).

   DEF VAR vExtrSum  AS DEC  INITIAL 0 NO-UNDO.
   DEF VAR vContType AS CHAR NO-UNDO.

   DEF BUFFER loan     FOR loan.
   DEF BUFFER loan-int FOR loan-int.

   FIND FIRST loan WHERE loan.contract  EQ iContract
                     AND loan.cont-code EQ iContCode
                   NO-LOCK NO-ERROR.

   IF AVAIL loan THEN
      vContType = loan.cont-type.

   IF vContType NE "Течение" THEN
   DO:
      FOR EACH loan-int WHERE loan-int.contract  EQ iContract
                          AND loan-int.cont-code EQ iContCode
                          AND loan-int.mdate     LE iDate
                          AND loan-int.id-d      EQ 0
                          AND loan-int.id-k      EQ 3
                        NO-LOCK:
         vExtrSum = vExtrSum + loan-int.amt-rub.
      END.
   END. 
   ELSE IF vContType EQ "Течение" THEN
   DO:
      FOR EACH loan WHERE loan.contract                    EQ iContract
                      AND loan.cont-code               BEGINS iContCode + " "
                      AND NUM-ENTRIES(loan.cont-code, " ") EQ 2
                      AND loan.open-date                   LE iDate
                    NO-LOCK:

         FOR EACH loan-int WHERE loan-int.contract  EQ loan.contract
                             AND loan-int.cont-code EQ loan.cont-code
                             AND loan-int.mdate     LE iDate
                             AND loan-int.id-d      EQ 0
                             AND loan-int.id-k      EQ 3             
                           NO-LOCK:
            vExtrSum = vExtrSum + loan-int.amt-rub.
         END.
      END.
   END.

   RETURN vExtrSum.

END FUNCTION. /* LnGetExtraditionSum */



/*---------------------------------------------------------------------------
  Function   : LnGetProvAcct
  Name       : Возвращает сумму обеспечения по счету.
  Purpose    : Возвращает сумму обеспечения по счету.
  Parameters : iAcct - номер ссудного счета.
  Parameters : iDate - дата на которую производится расчет.
  Notes      :
  ---------------------------------------------------------------------------*/
FUNCTION LnGetProvAcct RETURNS DECIMAL (INPUT iAcct AS CHAR,
                                        INPUT iDate AS DATE).
   /* переменные */
   DEFINE VARIABLE vProvSum   AS DECIMAL   NO-UNDO. /* общая сумма обеспечения, результат возвращаемый функцией */
   DEFINE VARIABLE vObSum     AS DECIMAL   NO-UNDO. /* обеспечение для охватывающего */
   DEFINE VARIABLE vTranshSum AS DECIMAL   NO-UNDO. /* общая сумма обеспечения траншей, за искл. анализируемого транша */
   DEFINE VARIABLE vCurSum    AS DECIMAL   NO-UNDO. /* просто сумма  */
   DEFINE VARIABLE vCurStr    AS CHARACTER NO-UNDO. /* просто строка */
   
   /* локализация буферов */
   DEFINE BUFFER loan        FOR loan. 
   DEFINE BUFFER bloan       FOR loan. 
   DEFINE BUFFER acct        FOR acct.
   DEFINE BUFFER term-obl    FOR term-obl. 
   DEFINE BUFFER loan-acct   FOR loan-acct. 
   DEFINE BUFFER bloan-acct  FOR loan-acct.
   DEFINE BUFFER btt-Loan-ob FOR tt-Loan-ob.

   {empty tt-Loan-ob}
   {find-act.i &acct = iAcct}

   /* идем по связям счета */
   FOR EACH loan-acct WHERE loan-acct.acct      EQ acct.acct
                        AND loan-acct.currency  EQ acct.currency 
                        AND loan-acct.contract  EQ "Кредит" 
                        AND loan-acct.since     LE iDate 
                        AND loan-acct.acct-type EQ "Кредит"
                        AND NOT CAN-FIND (FIRST bloan-acct WHERE bloan-acct.contract  EQ loan-acct.contract
                                                             AND bloan-acct.cont-code EQ loan-acct.cont-code
                                                             AND bloan-acct.acct-type EQ loan-acct.acct-type
                                                             AND bloan-acct.since     LE iDate
                                                             AND bloan-acct.since     GT loan-acct.since NO-LOCK)

   NO-LOCK, 
      FIRST loan WHERE loan.contract  EQ loan-acct.contract 
                   AND loan.cont-code EQ loan-acct.cont-code 
                   AND loan.open-date LE iDate
                   AND loan.cont-type NE "Течение" /* исключаем охватывающие, т.к. будем считать по траншам */
                   AND ( loan.close-date EQ ? 
                      OR loan.close-date GT iDate )    
      NO-LOCK BREAK BY ENTRY(1, loan-acct.cont-code , " ") BY loan-acct.since :
      /* расчет обеспечения по текущему договору */
      vCurSum = 0.
      FOR EACH term-obl WHERE (    term-obl.contract   EQ loan.contract
                               AND term-obl.cont-code  EQ loan.cont-code
                               AND term-obl.idnt       EQ 5
                               AND term-obl.end-date   GT iDate 
                               AND term-obl.fop-date   LE iDate )
                           OR
                              (    term-obl.contract   EQ loan.contract
                               AND term-obl.cont-code  EQ loan.cont-code
                               AND term-obl.idnt       EQ 5
                               AND term-obl.end-date   EQ ? 
                               AND term-obl.fop-date   LE iDate )
      NO-LOCK:
         vCurStr =  GetXattrValueEx("term-obl", term-obl.contract + "," +
                                    term-obl.cont-code + "," +
                                    STRING(term-obl.idnt) + "," +
                                    STRING(term-obl.end-date) + "," +
                                    STRING(term-obl.nn),
                                    "ВидДогОб",
                                    "").
         IF CAN-DO("КредОб,КредОбМет,КредЦБум", vCurStr) THEN            
            vCurSum = vCurSum + CurToBase("УЧЕТНЫЙ", term-obl.currency, iDate , term-obl.amt-rub).
      END.
      /* транши, у которых обеспечение на охватывающем */
      IF     NUM-ENTRIES(loan.cont-code,' ') GT 1 
         AND vCurSum EQ 0 THEN
      DO:
         /* ищем охватывающий для нашего транша */
         FIND LAST  bloan-acct WHERE bloan-acct.contract  EQ loan.contract
                                 AND bloan-acct.cont-code EQ ENTRY(1, loan.cont-code , " ")
                                 AND bloan-acct.since     LE iDate
                                 AND bloan-acct.acct-type EQ "Кредит"
         NO-LOCK NO-ERROR. 
         IF AVAIL bloan-acct  
            /* по одному охватывающему мы можем пройтись лишь 1н раз, что бы не насчитать лишнего */
            AND NOT CAN-FIND (FIRST tt-Loan-ob WHERE tt-Loan-ob.ContCode EQ bloan-acct.cont-code
                                                 AND tt-Loan-ob.Acct     EQ bloan-acct.acct ) THEN
         DO:
            ASSIGN 
               vObSum = 0
               vTranshSum = LnPrincipal(bloan-acct.contract, bloan-acct.cont-code, iDate, bloan-acct.currency) 
            . 
            /* общая сумма обеспечения по охватывающему */    
            FOR EACH term-obl WHERE (    term-obl.contract   EQ bloan-acct.contract
                                     AND term-obl.cont-code  EQ bloan-acct.cont-code 
                                     AND term-obl.idnt       EQ 5
                                     AND term-obl.end-date   GT iDate 
                                     AND term-obl.fop-date   LE iDate  )
                                 OR
                                    (    term-obl.contract   EQ bloan-acct.contract
                                     AND term-obl.cont-code  EQ bloan-acct.cont-code 
                                     AND term-obl.idnt       EQ 5
                                     AND  term-obl.end-date  EQ ? 
                                     AND term-obl.fop-date   LE iDate  )
            NO-LOCK:
               vCurStr =  GetXattrValueEx("term-obl", term-obl.contract + "," +
                                          term-obl.cont-code + "," +
                                          STRING(term-obl.idnt) + "," +
                                          STRING(term-obl.end-date) + "," +
                                          STRING(term-obl.nn),
                                          "ВидДогОб",
                                          "") .
               IF CAN-DO("КредОб,КредОбМет,КредЦБум", vCurStr) THEN  
                  vObSum = vObSum + CurToBase("УЧЕТНЫЙ", term-obl.currency, iDate , term-obl.amt-rub).
            END. 

            /* проходим по всем действующим траншам в рамках охватывающего */
            FOR EACH bloan WHERE bloan.contract     EQ loan.contract
                             AND bloan.cont-code    BEGINS ENTRY(1, loan.cont-code , " ") + " "
                             AND bloan.open-date    LE iDate
                             AND ( bloan.close-date EQ ? 
                                OR bloan.close-date GT iDate )  
            NO-LOCK,
               FIRST bloan-acct WHERE bloan-acct.contract  EQ bloan.contract
                                  AND bloan-acct.cont-code EQ bloan.cont-code
                                  AND bloan-acct.acct-type EQ "Кредит"
               NO-LOCK BREAK BY ENTRY(1, bloan.cont-code , " ") BY bloan.open-date:
               /* смотрим имеются ли у нас в тт записи */
               FIND FIRST tt-Loan-ob WHERE tt-Loan-ob.ContCode EQ ENTRY(1, loan.cont-code , " ")
                                       AND tt-Loan-ob.Acct     EQ bloan-acct.acct
               NO-ERROR.
               IF NOT AVAIL tt-Loan-ob THEN 
               DO:
                  CREATE tt-Loan-ob. 
                  ASSIGN
                     tt-Loan-ob.ContCode  = ENTRY(1, loan.cont-code , " ")
                     tt-Loan-ob.Acct      = bloan-acct.acct   
                     tt-Loan-ob.ObSum     = vObSum    
                     tt-Loan-ob.TranshSum = vTranshSum 
                     tt-Loan-ob.IfTransh  = YES
                  .                   
               END.
               tt-Loan-ob.AcctSum   = tt-Loan-ob.AcctSum + LnPrincipal(bloan-acct.contract, bloan-acct.cont-code, iDate, bloan-acct.currency).  
               IF LAST-OF(ENTRY(1, bloan.cont-code , " ")) THEN
                  tt-Loan-ob.IfLast = YES.
            END.            
         END.
      END. ELSE 
      /* остальные кредитные договора */
      DO:
         CREATE tt-Loan-ob. 
         ASSIGN
            tt-Loan-ob.ContCode  = loan.cont-code 
            tt-Loan-ob.Acct      = loan-acct.acct   
            tt-Loan-ob.ObSum     = vCurSum    
            tt-Loan-ob.TranshSum = 0  
            tt-Loan-ob.AcctSum   = LnPrincipal(loan-acct.contract, loan-acct.cont-code, iDate, loan-acct.currency)   
            tt-Loan-ob.IfLast    = NO  
            tt-Loan-ob.IfTransh  = NO
         .
      END.
   END.

   /* расчет */
   FOR EACH tt-Loan-ob WHERE tt-Loan-ob.Acct EQ iAcct
   NO-LOCK:
      /* обычные кредитные договора */
      IF tt-Loan-ob.IfTransh EQ NO THEN
         vProvSum = vProvSum + MIN(tt-Loan-ob.ObSum , tt-Loan-ob.AcctSum ).   
      ELSE  
      /* если транш, но не последний, то пропорция */
      IF tt-Loan-ob.IfLast EQ NO THEN 
         /* сумма обеспечения не может быть больше самого транша */
         vProvSum = vProvSum + MIN(ROUND(tt-Loan-ob.ObSum * tt-Loan-ob.AcctSum / tt-Loan-ob.TranshSum , 2)  , tt-Loan-ob.AcctSum ).
      ELSE 
      /* если транш последний, то ищем ошибку округления */ 
      IF tt-Loan-ob.IfLast EQ YES THEN 
      DO:
         FOR EACH btt-Loan-ob WHERE btt-Loan-ob.ContCode EQ tt-Loan-ob.ContCode 
                                AND btt-Loan-ob.acct     NE iAcct
         NO-LOCK:
            tt-Loan-ob.ObSum = tt-Loan-ob.ObSum - ROUND((btt-Loan-ob.ObSum * btt-Loan-ob.AcctSum / btt-Loan-ob.TranshSum), 2).
         END.
         vProvSum = vProvSum + MIN(tt-Loan-ob.ObSum , tt-Loan-ob.AcctSum).         
      END.
   END.
      
   RETURN vProvSum.

END FUNCTION. /* LnGetProvAcct */




